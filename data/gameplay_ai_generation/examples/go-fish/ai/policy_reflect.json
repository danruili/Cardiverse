{
    "game_description": "Go Fish is a fun game that will amuse and entertain even the youngest card players. It is similar to the game Authors.\n\n### The Pack\n\nThe standard 52-card pack is used. Some cards will be dealt and the rest will form the stock pile.\n\nShop our Hoyle 6 in 1 Fun Pack\n\n### Object of the Game\n\nThe goal is to win the most \"books\" of cards. A book is any four of a kind, such as four kings, four aces, and so on.\n\n### Rank of Cards\n\nThe cards rank from ace (high) to two (low). The suits are not important, only the card numbers are relevant, such as two 3s, two 10s, and so on.\n\n### The Deal\n\nAny player deals one card face up to each player. The player with the lowest card is the dealer. The dealer shuffles the cards, and the player to the right cuts them.\n\nThe dealer completes the cut and deals the cards clockwise one at a time, face down, beginning with the player to the left. If two or three people are playing, each player receives seven cards. If four or five people are playing, each receives five cards. The remainder of the pack is placed face down on the table to form the stock.\n\n### The Play\n\nThe player to the left of the dealer looks directly at any opponent and says, for example, \"Give me your kings,\" usually addressing the opponent by name and specifying the rank that they want, from ace down to two. The player who is \"fishing \u201cmust have at least one card of the rank that was asked for in their hand. The player who is addressed must hand over all the cards requested. If the player has none, they say, \"Go fish!\" and the player who made the request draws the top card of the stock and places it in their hand.\n\nIf a player gets one or more cards of the named rank that was asked for, they are entitled to ask the same or another player for a card. The player can ask for the same card or a different one. So long as the player succeeds in getting cards (makes a catch), their turn continues. When a player makes a catch, they must reveal the card so that the catch is verified. If a player gets the fourth card of a book, the player shows all four cards, places them on the table face up in front of everyone, and plays again.\n\nIf the player goes fishing without \"making a catch\" (does not receive a card he asked for), the turn passes to the left.\n\nThe game ends when all thirteen books have been won. The winner is the player with the most books. During the game, if a player is left without cards, they may (when it's their turn to play), draw from the stock and then ask for cards of that rank. If there are no cards left in the stock, they are out of the game.",
    "input_description": "Example: \n{\"common\": {\"num_players\": 4, \"current_player\": 0, \"winner\": null, \"is_over\": false, \"books\": [0, 0, 0, 0], \"facedown_cards\": {\"stock_size\": 28}}, \"players\": [{\"public\": {\"current_player\": true}, \"facedown_cards\": {\"hand\": [{\"rank\": \"Q\"}, {\"rank\": \"Q\"}, {\"rank\": \"8\"}, {\"rank\": \"Q\"}]}, \"faceup_cards\": {\"books\": []}}, {\"public\": {}, \"facedown_cards\": {\"hand_size\": 7}, \"faceup_cards\": {\"books\": []}}, {\"public\": {}, \"facedown_cards\": {\"hand_size\": 7}, \"faceup_cards\": {\"books\": []}}, {\"public\": {}, \"facedown_cards\": {\"hand_size\": 6}, \"faceup_cards\": {\"books\": []}}], \"recent_history\": [{\"type\": \"action\", \"player_id\": 0, \"action\": {\"action\": \"request\", \"args\": {\"target_player\": 3, \"rank\": \"Q\"}}, \"msg\": \"Player 0 decides to: request-(target_player: 3, rank: Q)\"}, {\"type\": \"info\", \"msg\": \"Player 0 takes an action: {'action': 'request', 'args': {'target_player': 3, 'rank': 'Q'}}\", \"role\": null}, {\"type\": \"info\", \"msg\": \"Player 0 requests rank Q from Player 3.\", \"role\": null}, {\"type\": \"info\", \"msg\": \"Player 3 says 'Go Fish!'.\", \"role\": null}, {\"type\": \"info\", \"msg\": \"Player 0 draws 3 from stock.\", \"role\": null}, {\"type\": \"info\", \"msg\": \"Next player is Player 1.\", \"role\": null}, {\"type\": \"turn_end\", \"player_id\": 0, \"msg\": \"---------- End of Player 0's turn ----------\"}, {\"type\": \"action\", \"player_id\": 1, \"action\": {\"action\": \"request\", \"args\": {\"target_player\": 0, \"rank\": \"3\"}, \"id\": 2}, \"msg\": \"Player 1 decides to: request-(target_player: 0, rank: 3)\"}, {\"type\": \"info\", \"msg\": \"Player 1 takes an action: {'action': 'request', 'args': {'target_player': 0, 'rank': '3'}, 'id': 2}\", \"role\": null}, {\"type\": \"info\", \"msg\": \"Player 1 requests rank 3 from Player 0.\", \"role\": null}, {\"type\": \"info\", \"msg\": \"Player 0 gives 1 card(s) to Player 1.\", \"role\": null}, {\"type\": \"turn_end\", \"player_id\": 1, \"msg\": \"---------- End of Player 1's turn ----------\"}, {\"type\": \"action\", \"player_id\": 1, \"action\": {\"action\": \"request\", \"args\": {\"target_player\": 0, \"rank\": \"9\"}, \"id\": 3}, \"msg\": \"Player 1 decides to: request-(target_player: 0, rank: 9)\"}, {\"type\": \"info\", \"msg\": \"Player 1 takes an action: {'action': 'request', 'args': {'target_player': 0, 'rank': '9'}, 'id': 3}\", \"role\": null}, {\"type\": \"info\", \"msg\": \"Player 1 requests rank 9 from Player 0.\", \"role\": null}, {\"type\": \"info\", \"msg\": \"Player 0 says 'Go Fish!'.\", \"role\": null}, {\"type\": \"info\", \"msg\": \"Player 1 draws 4 from stock.\", \"role\": null}, {\"type\": \"info\", \"msg\": \"Next player is Player 2.\", \"role\": null}, {\"type\": \"turn_end\", \"player_id\": 1, \"msg\": \"---------- End of Player 1's turn ----------\"}, {\"type\": \"action\", \"player_id\": 2, \"action\": {\"action\": \"request\", \"args\": {\"target_player\": 0, \"rank\": \"K\"}, \"id\": 0}, \"msg\": \"Player 2 decides to: request-(target_player: 0, rank: K)\"}, {\"type\": \"info\", \"msg\": \"Player 2 takes an action: {'action': 'request', 'args': {'target_player': 0, 'rank': 'K'}, 'id': 0}\", \"role\": null}, {\"type\": \"info\", \"msg\": \"Player 2 requests rank K from Player 0.\", \"role\": null}, {\"type\": \"info\", \"msg\": \"Player 0 gives 1 card(s) to Player 2.\", \"role\": null}, {\"type\": \"turn_end\", \"player_id\": 2, \"msg\": \"---------- End of Player 2's turn ----------\"}, {\"type\": \"action\", \"player_id\": 2, \"action\": {\"action\": \"request\", \"args\": {\"target_player\": 0, \"rank\": \"7\"}, \"id\": 2}, \"msg\": \"Player 2 decides to: request-(target_player: 0, rank: 7)\"}, {\"type\": \"info\", \"msg\": \"Player 2 takes an action: {'action': 'request', 'args': {'target_player': 0, 'rank': '7'}, 'id': 2}\", \"role\": null}, {\"type\": \"info\", \"msg\": \"Player 2 requests rank 7 from Player 0.\", \"role\": null}, {\"type\": \"info\", \"msg\": \"Player 0 says 'Go Fish!'.\", \"role\": null}, {\"type\": \"info\", \"msg\": \"Player 2 draws 6 from stock.\", \"role\": null}, {\"type\": \"info\", \"msg\": \"Next player is Player 3.\", \"role\": null}, {\"type\": \"turn_end\", \"player_id\": 2, \"msg\": \"---------- End of Player 2's turn ----------\"}, {\"type\": \"action\", \"player_id\": 3, \"action\": {\"action\": \"request\", \"args\": {\"target_player\": 1, \"rank\": \"5\"}, \"id\": 9}, \"msg\": \"Player 3 decides to: request-(target_player: 1, rank: 5)\"}, {\"type\": \"info\", \"msg\": \"Player 3 takes an action: {'action': 'request', 'args': {'target_player': 1, 'rank': '5'}, 'id': 9}\", \"role\": null}, {\"type\": \"info\", \"msg\": \"Player 3 requests rank 5 from Player 1.\", \"role\": null}, {\"type\": \"info\", \"msg\": \"Player 1 says 'Go Fish!'.\", \"role\": null}, {\"type\": \"info\", \"msg\": \"Player 3 draws 8 from stock.\", \"role\": null}, {\"type\": \"info\", \"msg\": \"Next player is Player 0.\", \"role\": null}], \"legal_actions\": [{\"action\": \"request\", \"args\": {\"target_player\": 1, \"rank\": \"Q\"}, \"id\": 0}, {\"action\": \"request\", \"args\": {\"target_player\": 1, \"rank\": \"8\"}, \"id\": 1}, {\"action\": \"request\", \"args\": {\"target_player\": 2, \"rank\": \"Q\"}, \"id\": 2}, {\"action\": \"request\", \"args\": {\"target_player\": 2, \"rank\": \"8\"}, \"id\": 3}, {\"action\": \"request\", \"args\": {\"target_player\": 3, \"rank\": \"Q\"}, \"id\": 4}, {\"action\": \"request\", \"args\": {\"target_player\": 3, \"rank\": \"8\"}, \"id\": 5}, {\"action\": \"draw\", \"id\": 6}]}\n\nExplanation: \n{\"common\": \"A dictionary containing common information about the game shared among all players.\", \"common.num_players\": \"The total number of players in the game.\", \"common.current_player\": \"The index of the player whose turn it is currently.\", \"common.winner\": \"The index of the winning player or null if the game is not over yet.\", \"common.is_over\": \"A boolean indicating if the game is over.\", \"common.books\": \"A list where each element represents the number of books completed by each player.\", \"common.facedown_cards.stock_size\": \"The number of cards remaining in the stock pile.\", \"players\": \"A list of dictionaries containing information about each player.\", \"players[i].public.current_player\": \"A boolean indicating whether the player 'i' is the current player.\", \"players[i].facedown_cards.hand\": \"The list of cards currently held by the player 'i', visible only to the player.\", \"players[i].facedown_cards.hand_size\": \"The number of cards in player's 'i' hand, visible to other players but without specific card details.\", \"players[i].faceup_cards.books\": \"A list of completed books by the player 'i', visible to all players.\", \"recent_history\": \"A list of actions, information and turn end logs for tracking the history of recent events and moves in the game.\", \"recent_history[i].type\": \"The type of entry in the recent history: 'action', 'info', or 'turn_end'.\", \"recent_history[i].player_id\": \"The ID of the player associated with the recent history entry, applicable for actions or turn end.\", \"recent_history[i].action\": \"A dictionary detailing the action taken by a player, if the entry type is 'action'.\", \"recent_history[i].msg\": \"A text message providing details about the history entry.\", \"recent_history[i].role\": \"The role or source of the information in the history entry, typically null.\", \"legal_actions\": \"A list of legal actions that the current player can take, including action type and arguments.\", \"legal_actions[i].action\": \"The type of action that can be taken, such as 'request' or 'draw'.\", \"legal_actions[i].args\": \"Additional arguments required for taking the action, if applicable.\", \"legal_actions[i].id\": \"A unique identifier for the action within the legal actions list.\"}",
    "policy_list": [
        "**Refined Memory Tracking Strategy**\nThe refined Memory Tracking strategy should involve systematically updating internal records of which cards have been asked for and the responses given. This involves:\n1. **Identify Critical Moments:** These are when a player has three of a rank and needs one more to form a book ('Potential Book Completion' is high), when an opponent has consistently asked for cards of a rank indicating they might own multiple ('Opponent Vulnerability Index' spikes), or when the player has few cards left and needs to prolong their turn ('Turn Continuation Probability' indicates a good chance to successfully acquire more cards).\n2. **Conditioned Actions:**\n   - Before taking any action, calculate the likelihood of success for each potential request based on historical data of opponent behaviors ('Opponent Vulnerability Index').\n   - Prioritize asking for ranks that aid in immediate book formation or are more likely to maintain turn control based on current hand and opponents' possible holdings.\n3. **Reducing Redundancy:** Track not just card holdings but also 'Go Fish' responses to prevent asking for ranks likely exhausted or that were met with consistent failures against specific players.\n4. **Dynamic Adjustment:** Continuously update evaluations at each turn end to dynamically adapt to evolving card distributions and maximize potential future benefits from learned patterns.",
        "**Priority on Completing Books**\nThe AI should focus on completing books by first asking for ranks where it holds three cards, since obtaining one additional card will secure a book. If no such trio exists, it should then target ranks with two cards, aiming to increase the number of ranks for which it has three cards, improving its chance of completing a book in subsequent turns. During a turn, the AI should also consider Opponent Vulnerability Index, asking opponents previously known to hold or request cards of those ranks, thus increasing the success rate of requests. Additionally, Stock Dependency and Turn Continuation Probability should guide decisions when asking for cards of ranks with fewer cards in hand. A focus should be placed on extending turns and strategically positioning the AI to utilize stock draws effectively when other actions are unlikely to succeed.",
        "**Opponent Weakness Exploitation**\nThe refined strategy entails identifying opponents with a high 'Opponent Vulnerability Index'\u2014those who have usually complied with card requests from the AI or other players. These opponents are more likely to hold cards required by the AI. The strategy should prioritize these players to increase the potential for successfully fishing cards, prolonging the turn, and forming more books. By using the game state metric like 'Opponent Vulnerability Index', the AI can dynamically adjust its target based on the changing game state and opponent behavior throughout the game.",
        "**Refined Balanced Stock Utilization**\nRefined Balanced Stock Utilization involves a detailed process of deciding when to draw from the stock based on the current game state:\n\n1. **Assess Potential Book Completion**: Monitor how many cards of a specific rank you currently hold and track past requests to estimate the likelihood of completing a book. Prioritize ranks with the highest potential when drawing from the stock.\n\n2. **Evaluate Opponent Vulnerability Index**: Calculate the chances that an opponent possesses the needed rank. This involves tracking their requests and responses. If Opponent Vulnerability Index is low, shift focus to drawing from the stock.\n\n3. **Determine Stock Dependency**: If you have a high dependency on the stock due to lacking synergies in your hand, prioritize ranks where drawing a card could complete a book or provide the ability to ask effectively in future turns.\n\n4. **Calculate Turn Continuation Probability**: Use this to decide whether it's more advantageous to fish directly from the stock or continue asking players where the chance of prolonging your turn is higher. Opt to draw if it promises a better setup for future actions.\n\nBy utilizing these metrics, the AI optimally decides whether to draw from the stock or request from opponents, increasing efficiency in book completion and turn continuation."
    ],
    "code": [
        "\ndef score(state: dict, action: dict) -> float:\n    # Extract important data points from the state\n    current_player_idx = state['common']['current_player']\n    current_hand = state['players'][current_player_idx]['facedown_cards']['hand']\n    stock_size = state['common']['facedown_cards']['stock_size']\n    books_by_current_player = len(state['players'][current_player_idx]['faceup_cards']['books'])\n    \n    # Extract action details\n    requested_rank = action['args'].get('rank')\n    target_player_idx = action['args'].get('target_player')\n    \n    # Check if the rank asked is in the player's hand to ensure it's a legal request\n    player_hand_ranks = [card['rank'] for card in current_hand]\n    \n    # Initialize a base score\n    base_score = 0.5\n    \n    # Increase base score if the player is potentially completing a book\n    if player_hand_ranks.count(requested_rank) == 3:\n        base_score += 0.2  # High chance of completing a book\n\n    # Analyze opponent's likely card holdings based on previous requests\n    recent_history = state['recent_history']\n    requested_by_others = [\n        entry for entry in recent_history\n        if entry['type'] == 'action' and entry['action']['args']['target_player'] == target_player_idx\n    ]\n    \n    opponent_likely_owns_rank = False\n    for request in requested_by_others:\n        if request['action']['args']['rank'] == requested_rank:\n            response_entry = next((entry for entry in recent_history if entry['type'] == 'info' and str(target_player_idx) in entry['msg']), None)\n            if response_entry and 'gives' in response_entry['msg']:\n                opponent_likely_owns_rank = True\n                break\n\n    if opponent_likely_owns_rank:\n        base_score += 0.15  # High chance that opponent will fulfill the request\n    \n    # Consider the remaining cards in stock for long-term strategy\n    if stock_size < 10:\n        base_score -= 0.1  # Reduced chance to recover in case of failure\n\n    # Normalize and bind the score within [0, 1]\n    result_score = max(0, min(1, base_score))\n\n    return result_score\n",
        "\ndef score(state: dict, action: dict) -> float:\n    \"\"\"\n    This function calculates the estimated probability of winning given the current game state and an action. It considers\n    factors such as opportunities to complete books, likelihood of successful requests, and other strategic elements.\n    \n    Parameters:\n    state (dict): The current state of the game, containing information about players, cards, and recent game history.\n    action (dict): The planned action the AI intends to take, including the request's target player and card rank or a draw action.\n\n    Returns:\n    float: A score representing the estimated likelihood of winning, ranging from 0 to 1.\n    \"\"\"\n    \n    # Extract necessary components from the state\n    current_player_index = state['common']['current_player']\n    current_player_hand = state['players'][current_player_index]['facedown_cards']['hand']\n    stock_size = state['common']['facedown_cards']['stock_size']\n    num_books = state['common']['books'][current_player_index]\n    total_books = sum(state['common']['books'])\n\n    # Count occurrences of each rank in the current player's hand\n    rank_counts = {}\n    for card in current_player_hand:\n        rank = card['rank']\n        if rank in rank_counts:\n            rank_counts[rank] += 1\n        else:\n            rank_counts[rank] = 1\n\n    # Calculate scores based on the current hand and action\n    result_score = 0.0\n\n    # 1. Priority on Completing Books\n    if action['action'] == \"request\":\n        requested_rank = action['args']['rank']\n        if rank_counts.get(requested_rank, 0) == 3:\n            result_score += 0.6  # High score for completing a book\n        elif rank_counts.get(requested_rank, 0) == 2:\n            result_score += 0.3  # Score for building towards a book\n\n    # 2. Opponent Vulnerability Index\n    # Evaluate potential success against more vulnerable opponents\n    target_player = action['args'].get('target_player', None)\n    if target_player is not None:\n        recent_requests_by_target = [\n            entry for entry in state['recent_history']\n            if entry['type'] == 'action' and entry['player_id'] == target_player\n            and entry['action']['action'] == 'request'\n        ]\n        for recent_request in recent_requests_by_target:\n            if recent_request['action']['args']['rank'] == requested_rank:\n                result_score += 0.1  # Increase score if opponent is likely to hold the card\n\n    # 3. Stock Dependency\n    if stock_size > 0 and action['action'] == \"draw\":\n        # Assign a baseline for drawing given the stock size\n        result_score += 0.1 / stock_size\n\n    # 4. Immediate Book Completion Scores\n    if total_books < 13:\n        proportional_books = num_books / 13.0\n        result_score += proportional_books\n\n    # Normalize to ensure score stays between 0 and 1\n    result_score = min(max(result_score, 0), 1)\n\n    return result_score\n",
        "\ndef score(state: dict, action: dict) -> float:\n    # Initialize the base reward score\n    result_score = 0.0\n\n    # Extract relevant information from the state and action\n    current_player = state['common']['current_player']\n    num_players = state['common']['num_players']\n    books_completed = state['common']['books']\n    remaining_stock = state['common']['facedown_cards']['stock_size']\n    legal_actions = state['legal_actions']\n    recent_history = state['recent_history']\n\n    # Calculate the potential for a book using the current hand\n    hand = [card['rank'] for card in state['players'][current_player]['facedown_cards']['hand']]\n    requested_rank = action['args']['rank']\n    hand_count = hand.count(requested_rank)\n\n    # Check if completing a book can be achieved with this action\n    if hand_count == 3:\n        result_score += 0.5  # High potential for completing a book\n\n    # Calculate the vulnerability index of the target player\n    target_player = action['args']['target_player']\n    vulnerability_index = 0\n\n    # Analyze the recent history to increase vulnerability index for players who frequently give cards\n    for entry in recent_history:\n        if entry['type'] == 'info' and f\"Player {target_player} gives\" in entry['msg']:\n            vulnerability_index += 1\n\n    # Adjust the score based on the vulnerability index\n    vulnerability_factor = vulnerability_index / len(recent_history) if len(recent_history) > 0 else 0\n    result_score += 0.3 * vulnerability_factor\n\n    # Consider the stage of the game based on the number of completed books\n    game_progression_factor = (sum(books_completed) + 1) / 13\n    result_score += 0.2 * game_progression_factor  # More weight as game progresses\n    \n    # Normalize the score to keep it between 0 and 1\n    result_score = min(1.0, max(0.0, result_score))\n\n    return result_score\n",
        "\ndef score(state: dict, action: dict) -> float:\n    num_players = state['common']['num_players']\n    current_player = state['common']['current_player']\n    stock_size = state['common']['facedown_cards']['stock_size']\n    \n    current_hand = state['players'][current_player]['facedown_cards']['hand']\n    current_books = len(state['players'][current_player]['faceup_cards']['books'])\n    \n    # Evaluate Refined Balanced Stock Utilization metrics\n    \n    # 1. Potential Book Completion\n    rank_count = {}\n    for card in current_hand:\n        rank_count[card['rank']] = rank_count.get(card['rank'], 0) + 1\n    \n    potential_completion_score = 0.0\n    if action['action'] == 'request':\n        requested_rank = action['args']['rank']\n        if rank_count.get(requested_rank, 0) == 3:\n            potential_completion_score = 1.0  # One card away from a book\n    \n    # 2. Opponent Vulnerability Index\n    vulnerability_index = 0.0\n    target_player = None\n    \n    if action['action'] == 'request':\n        target_player = action['args']['target_player']\n        vulnerability_index = 0.3  # Some baseline guess since we lack their hand details\n    \n    # 3. Stock Dependency\n    stock_dependency_score = 0.0\n    if action['action'] == 'draw':\n        if stock_size > 0:\n            stock_dependency_score = 0.1  # Baseline unless drawing assures book completion\n            for rank, count in rank_count.items():\n                if count == 3:\n                    stock_dependency_score = 0.9  # High potential for completing a book\n    \n    # 4. Turn Continuation Probability\n    turn_continuation_prob = 0.0\n    if action['action'] == 'request':\n        if target_player is not None:\n            turn_continuation_prob = 0.5  # Assumption if requesting based on policy\n    \n    # Calculate the overall score\n    result_score = (0.4 * potential_completion_score +\n                    0.2 * vulnerability_index +\n                    0.2 * stock_dependency_score +\n                    0.2 * turn_continuation_prob)\n\n    # Clamp score between 0 and 1\n    result_score = min(1.0, max(0.0, result_score))\n    \n    return result_score\n"
    ]
}