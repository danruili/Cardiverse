{
    "game_description": "**Setup**\n\n1.  **Players:** The game is for 2 to 6 players. Player 0 is the first player to start the game.\n2.  **The Deal:** Each player is dealt **7 cards**.\n3.  **The Piles:** The remaining cards are placed face-down to form the **Draw Pile**. The very top card of the Draw Pile is flipped over and placed face-up next to it to start the **Discard Pile**.\n4.  **First Card's Effect:** The first flipped card's effect is applied immediately at the start of the game:\n    * **Reverse:** The direction of play is reversed. The player to Player 0's right (Player 5 in a 6-player game) goes first.\n    * **Skip:** Player 0's first turn is skipped. The player next in the sequence goes first.\n    * **Draw 2:** Player 0 must draw 2 cards, and their turn is skipped.\n    * **Wild/Wild Draw 4:** A Wild card cannot be the first card. If one is flipped, it is shuffled back into the deck and a new card is drawn.\n\n**How to Play**\n\n1.  **The Objective:** Be the first player to get rid of all the cards in your hand.\n\n2.  **Taking Your Turn:** On your turn, you must match the card on top of the Discard Pile by playing a card from your hand with either the same **color**, **number**, or **action symbol**.\n    * For example, if the top card is a blue '7', you can play any blue card or any color '7' card. You could also play a special action card like a blue 'Skip' or a blue 'Draw 2'.\n\n3.  **Drawing a Card:** If you do not have a card that matches the one on the Discard Pile, you must draw one card from the Draw Pile. **This ends your turn.** You cannot play the card you just drew until your next turn.\n\n4.  **Special Cards:**\n    * **Skip:** The next player in the turn order loses their turn.\n    * **Reverse:** The direction of play reverses. If play was moving left, it now moves right, and vice-versa.\n    * **Draw 2:** The next player must draw 2 cards and loses their turn.\n    * **Wild:** The player who plays this card can change the active color to any of the four colors (red, green, blue, or yellow).\n    * **Wild Draw 4:** This card allows you to change the active color. Additionally, the next player must draw 4 cards and loses their turn.\n        * **Important Rule:** You can only play a **Wild Draw 4** card if you **do not have any other cards in your hand that match the color** of the card on the Discard Pile. You may still play it if you have cards of the same number/symbol but a different color.\n\n**Winning the Game & Scoring**\n\n1.  **Winning:** The game round ends as soon as one player plays their last card. That player is the winner of the round.\n\n2.  **Scoring:** Once a player wins, the other players receive penalty points based on the cards left in their hands:\n    * **Number Cards (0-9):** Face value (e.g., a '7' is worth 7 points)\n    * **Draw 2, Reverse, Skip:** 20 points each\n    * **Wild, Wild Draw 4:** 50 points each\n    The winner of the round receives 0 points.\n\n**Additional Rules**\n\n* **Empty Draw Pile:** If the Draw Pile ever runs out of cards, the Discard Pile (except for the very top card) is shuffled and turned over to become the new Draw Pile.\n",
    "input_description": "Example: \n{\"common\": {\"num_players\": 4, \"current_player\": 2, \"direction\": -1, \"winner\": null, \"is_over\": false, \"facedown_cards\": {\"deck_size\": 75}, \"faceup_cards\": {\"played_cards\": [{\"color\": \"green\", \"trait\": \"3\", \"type\": \"number\"}, {\"color\": \"black\", \"trait\": \"wild_draw_4\", \"type\": \"wild\"}, {\"color\": \"yellow\", \"trait\": \"0\", \"type\": \"number\"}, {\"color\": \"yellow\", \"trait\": \"skip\", \"type\": \"action\"}, {\"color\": \"black\", \"trait\": \"wild\", \"type\": \"wild\"}, {\"color\": \"yellow\", \"trait\": \"2\", \"type\": \"number\"}, {\"color\": \"yellow\", \"trait\": \"reverse\", \"type\": \"action\"}], \"target_card\": {\"color\": \"yellow\", \"trait\": \"reverse\", \"type\": \"action\"}}}, \"players\": [{\"public\": {}, \"facedown_cards\": {\"hand_size\": 6}, \"faceup_cards\": {}}, {\"public\": {}, \"facedown_cards\": {\"hand_size\": 10}, \"faceup_cards\": {}}, {\"public\": {\"current_player\": true}, \"private\": {}, \"facedown_cards\": {\"hand\": [{\"color\": \"red\", \"trait\": \"reverse\", \"type\": \"action\"}, {\"color\": \"green\", \"trait\": \"4\", \"type\": \"number\"}, {\"color\": \"red\", \"trait\": \"2\", \"type\": \"number\"}, {\"color\": \"blue\", \"trait\": \"3\", \"type\": \"number\"}, {\"color\": \"red\", \"trait\": \"9\", \"type\": \"number\"}]}, \"faceup_cards\": {}}, {\"public\": {}, \"facedown_cards\": {\"hand_size\": 5}, \"faceup_cards\": {}}], \"recent_history\": [{\"type\": \"action\", \"player_id\": 2, \"action\": {\"action\": \"play\", \"args\": {\"card_idx\": 1}, \"id\": 0}, \"msg\": \"Player 2 decides to: play-(card_idx: 1)\"}, {\"type\": \"info\", \"msg\": \"Player 2 plays yellow-2-number.\", \"role\": null}, {\"type\": \"turn_end\", \"player_id\": 2, \"msg\": \"---------- End of Player 2's turn ----------\"}, {\"type\": \"action\", \"player_id\": 3, \"action\": {\"action\": \"play\", \"args\": {\"card_idx\": 4}, \"id\": 1}, \"msg\": \"Player 3 decides to: play-(card_idx: 4)\"}, {\"type\": \"info\", \"msg\": \"Player 3 plays yellow-reverse-action.\", \"role\": null}], \"legal_actions\": [{\"action\": \"play\", \"args\": {\"card_idx\": 0}, \"id\": 0}]}\n\nExplanation: \n{\"common\": \"A dictionary containing non-player-related information about the game state.\", \"num_players\": \"The total number of players participating in the game.\", \"current_player\": \"The index of the player whose turn it currently is.\", \"direction\": \"The current direction of play. 1 indicates clockwise, and -1 indicates counter-clockwise.\", \"winner\": \"The index of the player who has won the game, if the game is over. Otherwise, it is null.\", \"is_over\": \"A boolean indicating whether the game has ended.\", \"facedown_cards\": \"A dictionary containing information about cards that are not visible to players.\", \"deck_size\": \"The number of cards remaining in the draw deck.\", \"faceup_cards\": \"A dictionary containing information about cards that have been played or are otherwise visible.\", \"played_cards\": \"A list of dictionaries, each representing a card that has been played. Each card dictionary includes fields such as 'color', 'trait', and 'type'.\", \"target_card\": \"The current card at the top of the played pile that the players must match on their turn.\", \"players\": \"A list of dictionaries, each representing a player's state in the game.\", \"public\": \"A dictionary containing public information about the player, excluding card-related fields.\", \"private\": \"A dictionary containing private information about the player, which is not visible to other players.\", \"facedown_cards:hand_size\": \"The number of cards held by a player. This is visible to all players.\", \"facedown_cards:hand\": \"A list of dictionaries, each representing a card in the current player's hand. This is only visible to the current player.\", \"recent_history\": \"A list of recent actions and events in the game, described as a series of dictionaries with details such as action type, player ID, and messages.\", \"legal_actions\": \"A list of dictionaries representing the possible actions the current player can take. Each dictionary includes the action type and any necessary arguments.\"}",
    "policy_list": [
        "**Color Management**\nFocus on balancing the colors of the cards in your hand, prioritizing playing cards that will keep a diverse color set remaining.",
        "**Action Card Utilization**\nUse action cards strategically to impair opponents or directly improve your hand's position.",
        "**Endgame Focus**\nIdentify when you're nearing the last few cards and start planning plays to end with action cards or Wild cards, which can be more versatile and impactful.",
        "**Opponent Observation**\nPay attention to the cards opponents play to infer potential weaknesses and try to force them to draw cards."
    ],
    "code": [
        "\ndef score(state: dict, action: dict) -> float:\n    common = state['common']\n    players = state['players']\n    current_player_index = common['current_player']\n    current_player = players[current_player_index]\n    target_card = common['faceup_cards']['target_card']\n    legal_actions = state['legal_actions']\n    \n    # Extract the planned action details\n    action_card_idx = action['args']['card_idx']\n    action_card = current_player['facedown_cards']['hand'][action_card_idx]\n\n    # Initialize score\n    result_score = 0.0\n\n    # Evaluate color management\n    hand_colors = [card['color'] for card in current_player['facedown_cards']['hand']]\n    distinct_colors = len(set(hand_colors))\n    target_color = target_card['color']\n\n    if action_card['color'] == target_color:\n        # Matching color\n        result_score += 0.2\n    elif action_card['color'] != 'black':  # black cards are wild and don't count as a color\n        # Diverging color\n        result_score -= 0.1\n\n    # Action card effect analysis\n    if action_card['type'] == 'wild' or action_card['color'] == 'black':\n        result_score += 0.3  # Playing a wild card is typically strategic\n        if action_card['trait'] == 'wild_draw_4':\n            # Check the legality of playing a wild draw 4\n            if all(card['color'] != target_card['color'] for card in current_player['facedown_cards']['hand']):\n                result_score += 0.2\n    elif action_card['trait'] == 'draw_2':\n        # Playing a draw 2 card can be strategic\n        result_score += 0.1\n\n    # Consider the number of cards after the play\n    hand_size_after_play = len(current_player['facedown_cards']['hand']) - 1\n    if hand_size_after_play == 0:\n        # Winning the game\n        result_score = 1.0\n    else:\n        # Smaller hands generally have a better chance of winning\n        result_score += (1 / (hand_size_after_play + 1)) * 0.2\n\n    # Direction change or skip might give advantage\n    if action_card['type'] == 'action':\n        if action_card['trait'] == 'reverse' or action_card['trait'] == 'skip':\n            result_score += 0.1\n\n    # Normalize to range [0, 1]\n    result_score = min(max(result_score, 0.0), 1.0)\n\n    return result_score\n",
        "\ndef score(state: dict, action: dict) -> float:\n    # Extract relevant parts of the state\n    common = state[\"common\"]\n    players = state[\"players\"]\n    current_player = common[\"current_player\"]\n    target_card = common[\"faceup_cards\"][\"target_card\"]\n    \n    # Get the current player's hand and potential action card\n    player_hand = players[current_player][\"facedown_cards\"][\"hand\"]\n    card_idx = action[\"args\"][\"card_idx\"]\n    action_card = player_hand[card_idx]\n    \n    # Assess hand size impact\n    hand_size = len(player_hand)\n    min_hand_size = min([p['facedown_cards']['hand_size'] for p in players])\n    \n    # Establish a base score modifier for smaller hand size\n    hand_size_modifier = (min_hand_size / hand_size) if hand_size != 0 else 1\n    \n    # Calculate benefit of playing an action card\n    action_card_benefit = 0\n    if action_card['type'] == 'action' or action_card['type'] == 'wild':\n        if action_card['trait'] == 'reverse':\n            action_card_benefit = 0.05  # reverses play, may change strategy\n        elif action_card['trait'] == 'skip':\n            action_card_benefit = 0.1  # places opponent at disadvantage\n        elif action_card['trait'] == 'draw_2':\n            action_card_benefit = 0.2  # increases opponent's hand size\n        elif action_card['trait'].startswith('wild'):\n            action_card_benefit = 0.15  # flexibility and forcing +4 cards\n    \n    # Evaluate current player's advantage by hand\n    color_match = action_card['color'] == target_card['color']\n    trait_match = action_card['trait'] == target_card['trait']\n    match_bonus = 0.05 if color_match or trait_match else 0\n\n    # Score formula\n    result_score = (hand_size_modifier + action_card_benefit + match_bonus) / 3\n    result_score = min(max(result_score, 0), 1)  # Ensure score is between 0 and 1\n\n    return result_score\n",
        "\ndef score(state: dict, action: str) -> float:\n    num_cards = len(state[\"players\"][state[\"common\"][\"current_player\"]][\"facedown_cards\"][\"hand\"])\n    num_players = state[\"common\"][\"num_players\"]\n    deck_size = state[\"common\"][\"facedown_cards\"][\"deck_size\"]\n    target_card = state[\"common\"][\"faceup_cards\"][\"target_card\"]\n    hand = state[\"players\"][state[\"common\"][\"current_player\"]][\"facedown_cards\"][\"hand\"]\n    \n    # Calculate proximity to victory\n    proximity_score = 1 - (num_cards / 7)\n    \n    # Check for action cards in hand\n    action_cards = [card for card in hand if card[\"type\"] in [\"action\", \"wild\"]]\n    action_card_bonus = len(action_cards) / len(hand) if hand else 0\n    \n    # Assess the current legal action\n    legal_actions = state[\"legal_actions\"]\n    chosen_card_idx = next((la[\"args\"][\"card_idx\"] for la in legal_actions if la == action), None)\n    chosen_card = hand[chosen_card_idx] if chosen_card_idx is not None else None\n    \n    # Enhance score based on action cards and matching target card\n    if chosen_card:\n        match_bonus = 0.1 if (chosen_card[\"color\"] == target_card[\"color\"] or\n                              chosen_card[\"trait\"] == target_card[\"trait\"]) else 0\n        action_card_bonus += 0.1 if chosen_card in action_cards else 0\n    else:\n        match_bonus = 0\n    \n    # Factor in game state\n    game_stage_factor = max(0.5, 1 - deck_size / 108)\n    \n    # Combine to form final score\n    result_score = (0.5 * proximity_score +\n                    0.3 * action_card_bonus +\n                    0.1 * match_bonus +\n                    0.1 * game_stage_factor)\n    \n    # Ensure the score is in [0, 1]\n    result_score = min(1.0, max(0.0, result_score))\n    \n    return result_score\n",
        "\ndef score(state: dict, action: str) -> float:\n    # Initialize result score\n    result_score = 0.0\n    \n    # Extract necessary data from the state\n    num_players = state[\"common\"][\"num_players\"]\n    current_player = state[\"common\"][\"current_player\"]\n    facedown_cards = state[\"common\"][\"facedown_cards\"]\n    faceup_cards = state[\"common\"][\"faceup_cards\"]\n    players = state[\"players\"]\n    recent_history = state[\"recent_history\"]\n\n    # Calculate the number of cards in each player's hand\n    hand_sizes = [player[\"facedown_cards\"].get(\"hand_size\", len(player[\"facedown_cards\"].get(\"hand\", []))) for player in players]\n    \n    # Calculate basic metrics to infer winning probability\n    num_cards_in_hand = len(players[current_player][\"facedown_cards\"][\"hand\"])\n    \n    # Calculate base heuristic based on the number of cards in hand\n    base_score = (7 - num_cards_in_hand) / 7\n\n    # Observing recent history for potential weaknesses\n    opponent_hand_sizes = [size for idx, size in enumerate(hand_sizes) if idx != current_player]\n\n    # Determine pressure applied to opponents\n    active_effectiveness = 0\n    if \"play\" in action:\n        # Check if the played card is a special one:\n        if action[\"args\"][\"card_idx\"] in range(len(players[current_player][\"facedown_cards\"][\"hand\"])):\n            played_card = players[current_player][\"facedown_cards\"][\"hand\"][action[\"args\"][\"card_idx\"]]\n            card_type = played_card[\"type\"]\n            if card_type in [\"action\", \"wild\"]:\n                # Increase score if it's a special card\n                active_effectiveness = 0.15\n            if card_type == \"number\":\n                active_effectiveness = 0.05\n\n    # Combine terms into overall score\n    effectiveness_score = sum(1 / size for size in opponent_hand_sizes) / max(1, num_players - 1)\n    effectiveness_score *= active_effectiveness\n\n    # Create an observation component from previous turns for tactical play\n    historical_penalty = sum(hand_sizes) / (num_players * 7)\n    \n    # Final score is a combination of the above components with varying weights\n    result_score = base_score * 0.5 + effectiveness_score * 0.3 - historical_penalty * 0.2\n    \n    # Ensure result_score remains within [0,1]\n    result_score = max(0, min(1, result_score))\n\n    return result_score\n"
    ]
}