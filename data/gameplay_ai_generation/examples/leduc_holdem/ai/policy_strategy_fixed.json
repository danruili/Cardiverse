{
    "game_description": "Leduc Hold'em is a smaller version of Limit Texas Hold'em (first introduced in Bayes' Bluff: Opponent Modeling in Poker). The deck consists only two pairs of King, Queen and Jack, six cards in total. Each game is fixed with two players, two rounds, two-bet maximum and raise amounts of 2 and 4 in the first and second round. In the first round, one player is randomly choosed to put 1 unit in pot as small blind while the other puts 2 unit as big blind, and each player is dealt one card, then starts betting. The player with small blind acts first. In the second round, one public card is revealed first, then the players bet again. Finally, the player whose hand has the same rank as the public card is the winner. If neither, then the one with higher rank wins. Other rules such as 'fold' can refer to Limit Texas hold'em.",
    "input_description": "Example: \n{\"common\": {\"num_players\": 2, \"current_player\": 1, \"round\": 1, \"num_raises\": 1, \"last_raise\": 2, \"small_blind_player\": 0, \"big_blind_player\": 1, \"winner\": 0, \"is_over\": true, \"facedown_cards\": {\"deck_size\": 4}, \"faceup_cards\": {\"public_card\": null}}, \"players\": [{\"public\": {\"folded\": false, \"total_pot_contribution\": 4, \"round_pot_contribution\": 4, \"final_showdown\": true}, \"facedown_cards\": {\"hand\": [{\"rank\": \"Q\"}]}}, {\"public\": {\"folded\": true, \"total_pot_contribution\": 2, \"round_pot_contribution\": 2, \"current_player\": true}, \"facedown_cards\": {\"hand\": [{\"rank\": \"K\"}]}}], \"recent_history\": [{\"type\": \"action\", \"player_id\": 1, \"action\": {\"action\": \"fold\", \"id\": 0}, \"msg\": \"Player 1 decides to: fold\"}, {\"type\": \"info\", \"msg\": \"Player 1 chose action: fold\", \"role\": null}], \"legal_actions\": [{\"action\": \"fold\", \"id\": 0}, {\"action\": \"call\", \"id\": 1}, {\"action\": \"raise\", \"id\": 2}]}\n\nExplanation: \n{\"common\": {\"num_players\": \"The total number of players in the game, which is 2 for Leduc Hold'em.\", \"current_player\": \"The ID of the player whose turn it is currently. In this case, it's player 1.\", \"round\": \"Indicates which betting round is currently active. Round 1 or 2 are possible values.\", \"num_raises\": \"The number of raises that have occurred in the current round. Here it's 1.\", \"last_raise\": \"The amount of the last raise that was made. The value is 2 in this state.\", \"small_blind_player\": \"The ID of the player assigned as the small blind. Here it is player 0.\", \"big_blind_player\": \"The ID of the player assigned as the big blind. Here it is player 1.\", \"winner\": \"The ID of the player who won the game, or 'tie' if the game was a draw. In this case, player 0 is the winner.\", \"is_over\": \"A boolean indicating whether the game is over or not. Here it is true, meaning the game has ended.\", \"facedown_cards\": {\"deck_size\": \"The number of cards remaining in the deck. Here it is 4 cards.\"}, \"faceup_cards\": {\"public_card\": \"The public card revealed to all players, having no value implies it hasn't been revealed yet.\"}}, \"players\": [{\"public\": {\"folded\": \"A boolean that indicates whether the player has folded. False means player 0 has not folded.\", \"total_pot_contribution\": \"The total amount that the player has contributed to the pot. Here player 0 has contributed 4.\", \"round_pot_contribution\": \"The amount that the player has contributed to the pot in the current round, which is 4 for player 0.\", \"final_showdown\": \"A custom attribute that might suggest whether player 0 participated in the final showdown. The actual code doesn't define this attribute.\"}, \"facedown_cards\": {\"hand\": [{\"rank\": \"The rank of a card in the player's hand. Here, player 0 has a card with rank 'Q'.\"}]}}, {\"public\": {\"folded\": \"A boolean indicating whether the player has folded. True means player 1 has folded.\", \"total_pot_contribution\": \"The total amount that player 1 has contributed to the pot, which is 2.\", \"round_pot_contribution\": \"The amount that player 1 has contributed to the pot in the current round, which is also 2.\", \"current_player\": \"A custom attribute perhaps indicating player 1 was expected to act or was the last to act; however, not standard as per the code.\"}, \"facedown_cards\": {\"hand\": [{\"rank\": \"The rank of a card in the player's hand. In this instance, player 1 has a card with rank 'K'.\"}]}}], \"recent_history\": [{\"type\": \"action\", \"player_id\": 1, \"action\": {\"action\": \"fold\", \"id\": 0}, \"msg\": \"A message indicating that player 1 decided to fold.\"}, {\"type\": \"info\", \"msg\": \"A message confirming player 1 chose the fold action.\", \"role\": \"Potentially indicates the role of the message in the game, but is null here.\"}], \"legal_actions\": [{\"action\": \"fold\", \"id\": 0}, {\"action\": \"call\", \"id\": 1}, {\"action\": \"raise\", \"id\": 2}]}",
    "policy_list": [
        "**Bluffing with Low-Value Cards**\nIn situations where you have a low-value card, consider making aggressive bets or raises to make your opponent believe you have a high-value card. This can push them to fold and give you the pot without revealing cards.",
        "**Value Betting with High Cards**\nWhen you hold a high-value card, especially a pair or a card equal to the public card, bet or raise to maximize the pot size when you have the advantage.",
        "**Controlled Aggression**\nAdopt a strategy of selectively aggressive actions, such as raising during favorable situations while avoiding over-committing with uncertain hands.",
        "**Defensive Play with Marginal Hands**\nWith a marginal hand, focus on calling and checking rather than raising, especially if the opponent plays aggressively. Fold if the opponent shows significant strength and you lack favorable cards."
    ],
    "code": [
        "\ndef score(state: dict, action: str) -> float:\n    # Extract relevant information from the game state\n    current_player_id = state['common']['current_player']\n    current_round = state['common']['round']\n    num_raises = state['common']['num_raises']\n    public_card_info = state['common']['faceup_cards']['public_card']\n    \n    # Obtain the player's hand\n    player_hand = state['players'][current_player_id]['facedown_cards']['hand'][0]['rank']\n    \n    # Define the ranking of cards\n    card_rankings = {'K': 3, 'Q': 2, 'J': 1}\n    \n    # Evaluate the quality of the player's hand\n    hand_rank = card_rankings[player_hand]\n    \n    # Assume an initial score based on the player's card\n    result_score = hand_rank / max(card_rankings.values())\n    \n    # If a public card is revealed, adjust score based on card match\n    if public_card_info:\n        public_card_rank = card_rankings[public_card_info['rank']]  # Access rank within the dictionary\n        # If player's card matches the public card, increase their score significantly\n        if hand_rank == public_card_rank:\n            result_score += 0.4  # Significant increase since matching card improves win chances\n        elif hand_rank < public_card_rank:\n            result_score -= 0.2  # Decrease if lower than public card since chances are lowered\n\n    # Bluffing strategy - if the player has a low-value card, consider bluffing\n    if hand_rank == min(card_rankings.values()) and action == 'raise':\n        result_score += 0.3  # Bluff to increase pressure with low-value cards\n\n    # Adjust score based on number of raises\n    if num_raises > 0:\n        result_score -= 0.1 * num_raises  # More raises decrease the chance of winning, adjust score\n    \n    # Make sure score does not exceed [0, 1] bounds\n    result_score = max(0, min(1, result_score))\n\n    return result_score\n",
        "\ndef score(state: dict, action: dict) -> float:\n    # Extract relevant information from the state\n    players = state['players']\n    common = state['common']\n    legal_actions = [act['action'] for act in state['legal_actions']]\n    \n    current_player_index = common['current_player']\n    \n    # Check and extract public card rank safely\n    public_card = None\n    if 'public_card' in common['faceup_cards']:\n        public_card = common['faceup_cards']['public_card'] and common['faceup_cards']['public_card'].get('rank', None)\n    \n    # Extract the current player's hand\n    current_hand_rank = players[current_player_index]['facedown_cards']['hand'][0]['rank']\n    \n    # Define the rank order for the cards\n    rank_order = {'J': 1, 'Q': 2, 'K': 3}\n\n    # Initial win probability\n    win_prob = 0.5\n\n    # Adjust probability based on hand strength and action\n    if public_card:  # If a public card is present\n        if current_hand_rank == public_card:\n            # Higher probability if player has a card equal to public card\n            win_prob = 0.9\n        elif rank_order.get(current_hand_rank, 0) > rank_order.get(public_card, 0):\n            # Higher card than the public card gives a moderate advantage\n            win_prob = 0.7\n        else:\n            # Lower card rank than the public card\n            win_prob = 0.3\n    else:  # No public card case (First betting round)\n        if current_hand_rank == 'K':\n            # Maximum strength in absence of public card\n            win_prob = 0.8\n        elif current_hand_rank == 'Q':\n            # Moderate strength\n            win_prob = 0.6\n        else:\n            # Lowest strength initially\n            win_prob = 0.4\n\n    # Influence of legal actions and player's action choice\n    if action['action'] == 'fold':\n        return 0.0  # Folding guarantees no win\n    elif action['action'] == 'raise' and 'raise' in legal_actions:\n        win_prob += 0.1  # Raising generally indicates confidence, if legal\n        win_prob = min(win_prob, 1.0)  # Ensure win_prob doesn't exceed 1\n    elif action['action'] == 'call':\n        if 'raise' in legal_actions:\n            win_prob -= 0.1  # Calling instead of raising might be less confident\n            win_prob = max(win_prob, 0.0)  # Ensure win_prob doesn't go below 0\n\n    result_score = win_prob\n    return result_score\n",
        "\ndef score(state: dict, action: str) -> float:\n    # Getting current player and opponent player ids\n    current_player_id = state[\"common\"][\"current_player\"]\n    opponent_player_id = 1 if current_player_id == 0 else 0\n\n    # Default rank values for missing cards\n    default_rank = 'J'\n    \n    # Getting current player and opponent hand rank with checks\n    current_player_hand = state[\"players\"][current_player_id][\"facedown_cards\"].get(\"hand\", [{\"rank\": default_rank}])[0][\"rank\"]\n    opponent_hand = state[\"players\"][opponent_player_id][\"facedown_cards\"].get(\"hand\", [{\"rank\": default_rank}])[0][\"rank\"]\n\n    # Define rank order, higher is better\n    rank_order = {'J': 1, 'Q': 2, 'K': 3}\n\n    # Evaluate the situation\n    current_hand_rank_value = rank_order[current_player_hand]\n    opponent_hand_rank_value = rank_order[opponent_hand]\n\n    # Calculate a base winning probability based on hand ranks\n    hand_strength = 0.5\n    if current_hand_rank_value > opponent_hand_rank_value:\n        hand_strength = 0.75  # Favorable scenario\n    elif current_hand_rank_value < opponent_hand_rank_value:\n        hand_strength = 0.25  # Unfavorable scenario\n    else:\n        hand_strength = 0.5  # Even odds\n\n    # Bias the result based on a controlled aggression strategy\n    if action == \"raise\":\n        if current_hand_rank_value >= 2:\n            result_score = hand_strength + 0.1  # Raise more likely to be successful with Q or K\n        else:\n            result_score = hand_strength - 0.1  # Risky raise with J, discourage\n    elif action == \"call\":\n        result_score = hand_strength\n    elif action == \"fold\":\n        result_score = 0.1\n    else:\n        result_score = hand_strength\n\n    # Clamp the result score between 0 and 1\n    result_score = max(0, min(1, result_score))\n\n    return result_score\n",
        "\ndef score(state: dict, action: str) -> float:\n    # Extracting necessary information from the state\n    player_id = state[\"common\"][\"current_player\"]\n    player_hand_rank = state[\"players\"][player_id][\"facedown_cards\"][\"hand\"][0][\"rank\"]\n    public_card = state[\"common\"][\"faceup_cards\"][\"public_card\"]\n    legal_actions = [act[\"action\"] for act in state[\"legal_actions\"]]\n    \n    # Define rank order to compare card values\n    rank_order = {\"J\": 0, \"Q\": 1, \"K\": 2}\n    \n    # Determine if the player has a marginal hand\n    is_marginal_hand = player_hand_rank in rank_order\n\n    # Initialize win probability, starting from a base value\n    # that represents our starting belief in the hand strength\n    win_probability = 0.5\n    \n    # Adjust probability based on the actions and hand strength\n    if public_card is not None:\n        public_card_rank = public_card[\"rank\"]\n        if player_hand_rank == public_card_rank:\n            # If the player's card matches the public card, the win probability is high\n            win_probability = 0.9\n        else:\n            # If the public card is different, compare the ranks\n            if rank_order[player_hand_rank] > rank_order.get(public_card_rank, -1):\n                win_probability = 0.7\n            else:\n                win_probability = 0.3\n\n    # Consider action policy for marginal hands\n    if is_marginal_hand:\n        if action == \"call\":\n            win_probability += 0.1  # Slightly safer than raising with marginal hands\n        elif action == \"raise\" and \"raise\" in legal_actions:\n            win_probability -= 0.2  # Raising with marginal hands is riskier\n        elif action == \"fold\":\n            win_probability = 0.0  # Folding implies conceding the win\n\n    # Ensure the result remains within valid bounds [0, 1]\n    result_score = max(0.0, min(1.0, win_probability))\n    return result_score\n"
    ]
}