{
    "game_description": "Leduc Hold'em is a smaller version of Limit Texas Hold'em (first introduced in Bayes' Bluff: Opponent Modeling in Poker). The deck consists only two pairs of King, Queen and Jack, six cards in total. Each game is fixed with two players, two rounds, two-bet maximum and raise amounts of 2 and 4 in the first and second round. In the first round, one player is randomly choosed to put 1 unit in pot as small blind while the other puts 2 unit as big blind, and each player is dealt one card, then starts betting. The player with small blind acts first. In the second round, one public card is revealed first, then the players bet again. Finally, the player whose hand has the same rank as the public card is the winner. If neither, then the one with higher rank wins. Other rules such as 'fold' can refer to Limit Texas hold'em.",
    "input_description": "Example: \n{\"common\": {\"num_players\": 2, \"current_player\": 1, \"round\": 1, \"num_raises\": 1, \"last_raise\": 2, \"small_blind_player\": 0, \"big_blind_player\": 1, \"winner\": 0, \"is_over\": true, \"facedown_cards\": {\"deck_size\": 4}, \"faceup_cards\": {\"public_card\": null}}, \"players\": [{\"public\": {\"folded\": false, \"total_pot_contribution\": 4, \"round_pot_contribution\": 4, \"final_showdown\": true}, \"facedown_cards\": {\"hand\": [{\"rank\": \"Q\"}]}}, {\"public\": {\"folded\": true, \"total_pot_contribution\": 2, \"round_pot_contribution\": 2, \"current_player\": true}, \"facedown_cards\": {\"hand\": [{\"rank\": \"K\"}]}}], \"recent_history\": [{\"type\": \"action\", \"player_id\": 1, \"action\": {\"action\": \"fold\", \"id\": 0}, \"msg\": \"Player 1 decides to: fold\"}, {\"type\": \"info\", \"msg\": \"Player 1 chose action: fold\", \"role\": null}], \"legal_actions\": [{\"action\": \"fold\", \"id\": 0}, {\"action\": \"call\", \"id\": 1}, {\"action\": \"raise\", \"id\": 2}]}\n\nExplanation: \n{\"common\": {\"num_players\": \"The total number of players in the game, which is 2 for Leduc Hold'em.\", \"current_player\": \"The ID of the player whose turn it is currently. In this case, it's player 1.\", \"round\": \"Indicates which betting round is currently active. Round 1 or 2 are possible values.\", \"num_raises\": \"The number of raises that have occurred in the current round. Here it's 1.\", \"last_raise\": \"The amount of the last raise that was made. The value is 2 in this state.\", \"small_blind_player\": \"The ID of the player assigned as the small blind. Here it is player 0.\", \"big_blind_player\": \"The ID of the player assigned as the big blind. Here it is player 1.\", \"winner\": \"The ID of the player who won the game, or 'tie' if the game was a draw. In this case, player 0 is the winner.\", \"is_over\": \"A boolean indicating whether the game is over or not. Here it is true, meaning the game has ended.\", \"facedown_cards\": {\"deck_size\": \"The number of cards remaining in the deck. Here it is 4 cards.\"}, \"faceup_cards\": {\"public_card\": \"The public card revealed to all players, having no value implies it hasn't been revealed yet.\"}}, \"players\": [{\"public\": {\"folded\": \"A boolean that indicates whether the player has folded. False means player 0 has not folded.\", \"total_pot_contribution\": \"The total amount that the player has contributed to the pot. Here player 0 has contributed 4.\", \"round_pot_contribution\": \"The amount that the player has contributed to the pot in the current round, which is 4 for player 0.\", \"final_showdown\": \"A custom attribute that might suggest whether player 0 participated in the final showdown. The actual code doesn't define this attribute.\"}, \"facedown_cards\": {\"hand\": [{\"rank\": \"The rank of a card in the player's hand. Here, player 0 has a card with rank 'Q'.\"}]}}, {\"public\": {\"folded\": \"A boolean indicating whether the player has folded. True means player 1 has folded.\", \"total_pot_contribution\": \"The total amount that player 1 has contributed to the pot, which is 2.\", \"round_pot_contribution\": \"The amount that player 1 has contributed to the pot in the current round, which is also 2.\", \"current_player\": \"A custom attribute perhaps indicating player 1 was expected to act or was the last to act; however, not standard as per the code.\"}, \"facedown_cards\": {\"hand\": [{\"rank\": \"The rank of a card in the player's hand. In this instance, player 1 has a card with rank 'K'.\"}]}}], \"recent_history\": [{\"type\": \"action\", \"player_id\": 1, \"action\": {\"action\": \"fold\", \"id\": 0}, \"msg\": \"A message indicating that player 1 decided to fold.\"}, {\"type\": \"info\", \"msg\": \"A message confirming player 1 chose the fold action.\", \"role\": \"Potentially indicates the role of the message in the game, but is null here.\"}], \"legal_actions\": [{\"action\": \"fold\", \"id\": 0}, {\"action\": \"call\", \"id\": 1}, {\"action\": \"raise\", \"id\": 2}]}",
    "policy_list": [
        "**Refined Bluffing Strategy with Low-Value Cards**\nWhen holding a low-value card, consider bluffing aggressively (betting or raising) particularly in two scenarios: 1) When HandStrength is relatively weak, but PotOdds suggest a profitable risk due to a potentially large pot; 2) When OpponentModel suggests the opponent is cautious or holds a marginal hand. Increase AggressionFactor in these conditions to apply pressure. Bluff when you act first after the public card reveals and the revealed public card does not match your low card, thus preventing the opponent from easy calls if their card also doesn't match. Additionally, if the opponent showed minimal aggression in the first round, there's an opportunity to bluff more efficiently in the second round. Keep track of the opponent's reactions to continuous aggressive bets to refine OpponentModel further and adjust accordingly. These clarified criteria ensure the bluff is timely and justified by the game context, enhancing the chances of success.",
        "**Refined Value Betting Strategy**\nIn Leduc Hold'em, a high-value card is defined as either a pair with the public card or the highest rank available (King, then Queen, then Jack). The AI will employ value betting under the following conditions: In the first round, if holding a King, bet or raise to maximize pot size, as it is the highest rank before the public card is revealed. In the second round, if the public card matches the AI's card, bet or raise unless the PotOdds do not justify further investment. If the public card doesn't match but the AI has a King and the public card is a Queen or Jack, still consider an aggressive play if PotOdds and OpponentModel suggest a likelihood of winning. Evaluate HandStrength and increase AggressionFactor if the odds favor the AI's position. If the OpponentModel indicates a tendency for the opponent to fold under pressure, leverage this information by adopting a more aggressive stance with semi-strong hands. Conversely, if the opponent exhibits a strong response pattern, consider pulling back to conserve resources for stronger positions. This detailed approach ensures that value betting is aligned with specific game situations, maximizing its effectiveness.",
        "**Controlled Aggression**\nTo implement 'Controlled Aggression' in Leduc Hold'em, we can utilize several game state metrics:\n\n1. **HandStrength**: The AI should leverage aggression particularly when its current card is strong (e.g., a King) or matches the public card in the second round. This increases the AI's chance of winning during showdown, justifying raises or bets in these situations.\n\n2. **PotOdds**: If current pot odds are favorable (i.e., the pot size is large compared to the cost of calling or raising), the AI should lean towards aggressive actions such as betting or raising to capitalize on potentially profitable scenarios.\n\n3. **AggressionFactor**: The AI should maintain a higher aggression factor when it holds a premium or favorable hand, but should decrease its aggression if previous aggressive actions have not been successful or if the opponent exhibits strength via raises and bets.\n\n4. **OpponentModel**: By analyzing the opponent's betting patterns and style, the AI can tailor its aggression. For instance, against a passive opponent, the AI can increase its aggression to take control of the pot. Conversely, against an aggressive opponent, it might be wise to adopt a more conservative approach to aggression unless holding a strong hand.\n\nOverall, 'Controlled Aggression' is about finding a balance, where the AI consistently evaluates its position, actively adapts to the evolving game state, and makes informed decisions to maximize winning potential while minimizing unnecessary risks.",
        "**Defensive Play with Marginal Hands - Refined Strategy**\nWith a marginal hand, adopt a cautious approach through checking and calling where suitable. If facing opponent aggression, assess their aggression factor: \n- If high, and your hand strength or pot odds do not justify a potential loss, consider folding.\n- If moderate, evaluate the opponent's possible bluff (using OpponentModel), and proceed to call if your hand strength and pot odds provide reasonable equity. \nIncorporate game state metrics as follows:\n- HandStrength: Use this to determine the likelihood of holding the winning hand against the opponent. If your hand strength is higher relative to the public card and opponent's perceived range, consider betting more assertively rather than only defensive actions.\n- PotOdds: Calculate the pot odds before deciding to call any additional bets post-flop. Higher pot odds can make a call more appealing if there's sufficient equity.\n- AggressionFactor: Observe both your and your opponent's aggression factor to predict likely actions and outcomes.\n- OpponentModel: Use the assembled model of the opponent's behavior to identify bluffing opportunities or weaknesses in their playstyle, capitalizing on moments where they might overvalue their position or misjudge the board.\nOverall, defensive play prioritizes minimizing losses when uncertain, carefully balancing pot odds, hand strength, and opponent behavior to make informed choices in marginal situations."
    ],
    "code": [
        "\ndef score(state: dict, action: str) -> float:\n    def rank_value(rank: str) -> int:\n        rank_order = {'J': 0, 'Q': 1, 'K': 2}\n        return rank_order[rank]\n\n    def calculate_hand_strength(card_rank: str, public_card: str) -> float:\n        if card_rank == public_card:\n            return 1.0  # Best possible scenario\n        else:\n            return rank_value(card_rank) / 2.0\n\n    def evaluate_pot_odds(player_index: int) -> float:\n        player_contribution = state['players'][player_index]['public']['total_pot_contribution']\n        total_pot = sum(player['public']['total_pot_contribution'] for player in state['players'])\n        return player_contribution / total_pot if total_pot > 0 else 0\n\n    def opponent_aggression_factor(round_history, current_round) -> float:\n        raise_actions = [h for h in round_history if h['action']['action'] == 'raise' and h['player_id'] != state['common']['current_player']]\n        return len(raise_actions) / current_round\n\n    player_index = state['common']['current_player']\n    opponent_index = 1 - player_index\n    \n    # Extract necessary information from state for decision making\n    hand_card_rank = state['players'][player_index]['facedown_cards']['hand'][0]['rank']\n    public_card = state['common']['faceup_cards']['public_card']\n    hand_strength = calculate_hand_strength(hand_card_rank, public_card) if public_card else rank_value(hand_card_rank) / 2.0\n    \n    # Evaluate the pot odds\n    pot_odds = evaluate_pot_odds(player_index)\n    \n    # Evaluate opponent aggression\n    opponent_aggression = opponent_aggression_factor(state['recent_history'], state['common']['round'])\n    \n    # Determine whether to bluff or not, considering action and state\n    is_low_value_card = rank_value(hand_card_rank) < rank_value('Q')\n    action_is_aggressive = action in ['raise', 'bet']\n    \n    # Probability estimation based on multiple criteria\n    result_score = 0.1 * hand_strength + 0.3 * pot_odds + 0.2 * (1 - opponent_aggression)\n    \n    # Apply bluffing logic if appropriate\n    if is_low_value_card and action_is_aggressive:\n        if pot_odds > 0.2 and (opponent_aggression < 0.5 or hand_strength < 0.5):\n            result_score += 0.2\n\n    # Ensure result score is capped between 0 and 1\n    return max(0.0, min(1.0, result_score))\n",
        "\ndef score(state: dict, action: str) -> float:\n    # Unpack game state\n    common = state[\"common\"]\n    players = state[\"players\"]\n    current_player_id = common[\"current_player\"]\n    current_player_hand = players[current_player_id][\"facedown_cards\"][\"hand\"][0][\"rank\"]\n    public_card = common[\"faceup_cards\"][\"public_card\"]\n    \n    # Assign numerical values for cards\n    card_values = {'K': 3, 'Q': 2, 'J': 1}\n    \n    # Initialize win probability\n    win_probability = 0.5  # Starting with a neutral probability\n\n    # Evaluate current game state\n    if common[\"round\"] == 1:\n        # First round logic\n        if current_player_hand == 'K':\n            # Holding highest card\n            win_probability = 0.8\n        elif current_player_hand == 'Q':\n            # Holding second best card\n            win_probability = 0.6\n        elif current_player_hand == 'J':\n            win_probability = 0.4\n    elif common[\"round\"] == 2:\n        # Second round logic\n        if public_card:\n            if current_player_hand == public_card:\n                # Player has a pair with public card\n                win_probability = 0.9\n            else:\n                # No pair but check if holding King\n                if current_player_hand == 'K' and card_values[public_card] < card_values[current_player_hand]:\n                    win_probability = 0.75\n                else:\n                    win_probability = 0.4\n\n    # Adjust based on action\n    if action == \"raise\":\n        win_probability *= 1.1  # Aggressive play suggests confidence\n    elif action == \"call\":\n        win_probability *= 1.0  # Neutral play\n    elif action == \"fold\":\n        win_probability *= 0.5  # Defensive play, lower chance to win\n\n    # Ensure probability is within valid range\n    result_score = min(1.0, max(0.0, win_probability))\n    \n    return result_score\n",
        "\ndef score(state: dict, action: str) -> float:\n    def calculate_hand_strength(hand_card: str, public_card: str) -> float:\n        rank_order = {'J': 0, 'Q': 1, 'K': 2}\n        if public_card is None:\n            # Pre-flop strength: K strongest, then Q, then J.\n            return (rank_order[hand_card] + 1) / 3\n        else:\n            # Post-flop context: match with public card is strongest\n            if hand_card == public_card:\n                return 1.0\n            return 0.5 + (rank_order[hand_card] - rank_order[public_card]) * 0.25\n\n    def calculate_pot_odds(total_pot_contribution: int, last_raise: int, pot_size: int) -> float:\n        cost_to_call = last_raise - total_pot_contribution\n        if cost_to_call <= 0:\n            return 1.0\n        return pot_size / (pot_size + cost_to_call)\n\n    def evaluate_opponent_aggressiveness(recent_history: list) -> float:\n        opponent_raises = sum(1 for action in recent_history if action['type'] == 'action' and action['action']['action'] == 'raise')\n        total_actions = len(recent_history)\n        if total_actions == 0:\n            return 0.5\n        return opponent_raises / total_actions\n\n    current_player_id = state['common']['current_player']\n    player = state['players'][current_player_id]\n    hand_card = player['facedown_cards']['hand'][0]['rank']\n    public_card = state['common']['faceup_cards']['public_card']\n    \n    hand_strength = calculate_hand_strength(hand_card, public_card)\n    pot_size = sum(player['public']['total_pot_contribution'] for player in state['players'])\n    pot_odds = calculate_pot_odds(player['public']['total_pot_contribution'], state['common']['last_raise'], pot_size)\n    opponent_aggressiveness = evaluate_opponent_aggressiveness(state['recent_history'])\n\n    aggression_factor = 1.0\n    if action == 'raise':\n        aggression_factor = 1.25\n    elif action == 'call':\n        aggression_factor = 1.0\n    elif action == 'fold':\n        aggression_factor = 0.0\n\n    # Adjust hand strength based on a mix of pot odds and opponent aggressiveness\n    result_score = hand_strength * pot_odds * (1 - opponent_aggressiveness) * aggression_factor\n    # Clamp the result to be between 0 and 1\n    result_score = max(0.0, min(result_score, 1.0))\n\n    return result_score\n",
        "\ndef score(state: dict, action: str) -> float:\n    # Variables initialization\n    hand_strength = 0.0\n    pot_odds = 0.0\n    aggression_factor = 0.0\n    opponent_model = 0.0\n    total_pot = sum(player['public']['total_pot_contribution'] for player in state['players'])\n    \n    # Retrieve the current player's hand\n    current_player_id = state['common']['current_player']\n    current_hand = state['players'][current_player_id]['facedown_cards']['hand']\n    current_hand_rank = current_hand[0]['rank']\n    \n    # Calculate hand strength\n    if current_hand_rank == 'K':\n        hand_strength = 0.8\n    elif current_hand_rank == 'Q':\n        hand_strength = 0.6\n    elif current_hand_rank == 'J':\n        hand_strength = 0.4\n    \n    # Calculate pot odds\n    current_round_contribution = state['players'][current_player_id]['public']['round_pot_contribution']\n    call_amount = state['common']['last_raise'] - current_round_contribution\n    if call_amount > 0:\n        pot_odds = total_pot / call_amount\n    else:\n        pot_odds = 1.0  # If no extra cost to stay, pot odds is maximized\n    \n    # Estimate aggression factor\n    total_aggressive_actions = sum(1 for action in state['recent_history'] if action['type'] == 'action' and action['action']['action'] == 'raise')\n    total_actions = len(state['recent_history'])\n    if total_actions > 0:\n        aggression_factor = total_aggressive_actions / total_actions\n    \n    # Simple opponent model assumption: assume opponent bluffs 20% of the time\n    opponent_model = 0.2\n    \n    # Combine the metrics to calculate the score\n    # Basic estimation of win probability\n    # The weightings can be tuned based on game strategy and experiments\n    if action == \"fold\":\n        # Folding means surrendering so the winning probability is zero\n        result_score = 0.0\n    elif action == \"call\":\n        # Calling relies more on pot odds and hand strength\n        result_score = (hand_strength * 0.4) + (pot_odds * 0.3) + (1 - aggression_factor) * 0.2 + opponent_model * 0.1\n    elif action == \"raise\":\n        # Raising signifies confidence and uses more aggressive hand strength estimates\n        result_score = hand_strength * 0.6 + (1 - pot_odds) * 0.1 + (1 - aggression_factor) * 0.2 + opponent_model * 0.1\n\n    # Ensure the score is between 0 and 1\n    result_score = min(max(result_score, 0.0), 1.0)\n\n    return result_score\n"
    ]
}