{
    "game_description": "Leduc Hold'em is a smaller version of Limit Texas Hold'em (first introduced in Bayes' Bluff: Opponent Modeling in Poker). The deck consists only two pairs of King, Queen and Jack, six cards in total. Each game is fixed with two players, two rounds, two-bet maximum and raise amounts of 2 and 4 in the first and second round. In the first round, one player is randomly choosed to put 1 unit in pot as small blind while the other puts 2 unit as big blind, and each player is dealt one card, then starts betting. The player with small blind acts first. In the second round, one public card is revealed first, then the players bet again. Finally, the player whose hand has the same rank as the public card is the winner. If neither, then the one with higher rank wins. Other rules such as 'fold' can refer to Limit Texas hold'em.",
    "input_description": "Example: \n{\"common\": {\"num_players\": 2, \"current_player\": 1, \"round\": 1, \"num_raises\": 1, \"last_raise\": 2, \"small_blind_player\": 0, \"big_blind_player\": 1, \"winner\": 0, \"is_over\": true, \"facedown_cards\": {\"deck_size\": 4}, \"faceup_cards\": {\"public_card\": null}}, \"players\": [{\"public\": {\"folded\": false, \"total_pot_contribution\": 4, \"round_pot_contribution\": 4, \"final_showdown\": true}, \"facedown_cards\": {\"hand\": [{\"rank\": \"Q\"}]}}, {\"public\": {\"folded\": true, \"total_pot_contribution\": 2, \"round_pot_contribution\": 2, \"current_player\": true}, \"facedown_cards\": {\"hand\": [{\"rank\": \"K\"}]}}], \"recent_history\": [{\"type\": \"action\", \"player_id\": 1, \"action\": {\"action\": \"fold\", \"id\": 0}, \"msg\": \"Player 1 decides to: fold\"}, {\"type\": \"info\", \"msg\": \"Player 1 chose action: fold\", \"role\": null}], \"legal_actions\": [{\"action\": \"fold\", \"id\": 0}, {\"action\": \"call\", \"id\": 1}, {\"action\": \"raise\", \"id\": 2}]}\n\nExplanation: \n{\"common\": {\"num_players\": \"The total number of players in the game, which is 2 for Leduc Hold'em.\", \"current_player\": \"The ID of the player whose turn it is currently. In this case, it's player 1.\", \"round\": \"Indicates which betting round is currently active. Round 1 or 2 are possible values.\", \"num_raises\": \"The number of raises that have occurred in the current round. Here it's 1.\", \"last_raise\": \"The amount of the last raise that was made. The value is 2 in this state.\", \"small_blind_player\": \"The ID of the player assigned as the small blind. Here it is player 0.\", \"big_blind_player\": \"The ID of the player assigned as the big blind. Here it is player 1.\", \"winner\": \"The ID of the player who won the game, or 'tie' if the game was a draw. In this case, player 0 is the winner.\", \"is_over\": \"A boolean indicating whether the game is over or not. Here it is true, meaning the game has ended.\", \"facedown_cards\": {\"deck_size\": \"The number of cards remaining in the deck. Here it is 4 cards.\"}, \"faceup_cards\": {\"public_card\": \"The public card revealed to all players, having no value implies it hasn't been revealed yet.\"}}, \"players\": [{\"public\": {\"folded\": \"A boolean that indicates whether the player has folded. False means player 0 has not folded.\", \"total_pot_contribution\": \"The total amount that the player has contributed to the pot. Here player 0 has contributed 4.\", \"round_pot_contribution\": \"The amount that the player has contributed to the pot in the current round, which is 4 for player 0.\", \"final_showdown\": \"A custom attribute that might suggest whether player 0 participated in the final showdown. The actual code doesn't define this attribute.\"}, \"facedown_cards\": {\"hand\": [{\"rank\": \"The rank of a card in the player's hand. Here, player 0 has a card with rank 'Q'.\"}]}}, {\"public\": {\"folded\": \"A boolean indicating whether the player has folded. True means player 1 has folded.\", \"total_pot_contribution\": \"The total amount that player 1 has contributed to the pot, which is 2.\", \"round_pot_contribution\": \"The amount that player 1 has contributed to the pot in the current round, which is also 2.\", \"current_player\": \"A custom attribute perhaps indicating player 1 was expected to act or was the last to act; however, not standard as per the code.\"}, \"facedown_cards\": {\"hand\": [{\"rank\": \"The rank of a card in the player's hand. In this instance, player 1 has a card with rank 'K'.\"}]}}], \"recent_history\": [{\"type\": \"action\", \"player_id\": 1, \"action\": {\"action\": \"fold\", \"id\": 0}, \"msg\": \"A message indicating that player 1 decided to fold.\"}, {\"type\": \"info\", \"msg\": \"A message confirming player 1 chose the fold action.\", \"role\": \"Potentially indicates the role of the message in the game, but is null here.\"}], \"legal_actions\": [{\"action\": \"fold\", \"id\": 0}, {\"action\": \"call\", \"id\": 1}, {\"action\": \"raise\", \"id\": 2}]}",
    "policy_list": [
        "**HandStrength**\nEvaluates the strength of the AI player's hand based on the current card it holds and the public card if available. A stronger hand increases the likelihood of winning in showdown.",
        "**PotOdds**\nAssesses the ratio of the current size of the pot to the cost of a contemplated call. High pot odds may justify a call, even if the hand does not appear strong.",
        "**AggressionFactor**\nReflects the AI player's tendency to bet or raise rather than check or fold, considering the actions history in the current game. A higher factor suggests leveraging stronger perceived hands or bluffing potential against the opponent.",
        "**OpponentModel**\nEvaluates the opponent's likely hand strength and playing style based on observed actions and betting history. This helps predict the opponent's future moves and adjust the strategy accordingly."
    ],
    "code": [
        "\ndef score(state: dict, action: dict) -> float:\n    # Define card rank values\n    rank_values = {'J': 1, 'Q': 2, 'K': 3}\n\n    # Extract necessary information from state\n    current_player = state[\"common\"][\"current_player\"]\n    player_hand = state[\"players\"][current_player][\"facedown_cards\"][\"hand\"][0][\"rank\"]\n    public_card_info = state[\"common\"][\"faceup_cards\"][\"public_card\"]\n\n    # Extract the rank of the public card if available\n    public_card = public_card_info[\"rank\"] if public_card_info else None\n\n    # If public card is not revealed, use only the player's hand\n    if public_card is None:\n        # Calculate hand strength based solely on player's card\n        player_hand_value = rank_values[player_hand]\n        max_possible_value = max(rank_values.values())\n        hand_strength = player_hand_value / max_possible_value\n    else:\n        # Consider public card for hand strength\n        if player_hand == public_card:\n            hand_strength = 1.0  # Strongest possible hand\n        else:\n            player_hand_value = rank_values[player_hand]\n            public_card_value = rank_values[public_card]\n            hand_strength = player_hand_value / public_card_value\n\n    # Adjust score based on potential actions\n    legal_actions = {act[\"action\"] for act in state[\"legal_actions\"]}\n\n    # Initialize result_score to handle cases where the action is invalid\n    result_score = 0.0\n\n    # Consider the action being assessed\n    if action[\"action\"] == \"fold\":\n        result_score = 0.0  # Folding action, generally leads to losing the round\n    elif action[\"action\"] == \"call\":\n        result_score = hand_strength * 0.75  # Call conservatively\n    elif action[\"action\"] == \"raise\" and \"raise\" in legal_actions:\n        result_score = min(1.0, hand_strength * 1.25)  # More aggressive move\n    \n    return result_score\n",
        "\ndef score(state: dict, action: str) -> float:\n    # Extract necessary information from the state\n    current_player = state['common']['current_player']\n    current_round = state['common']['round']\n    current_raise = state['common']['num_raises']\n    last_raise = state['common']['last_raise']\n    pot_size = sum(player['public']['total_pot_contribution'] for player in state['players'])\n    \n    # Information about the current player's hand\n    current_hand_rank = state['players'][current_player]['facedown_cards']['hand'][0]['rank']\n    \n    # Define the rank ordering for evaluation\n    rank_order = {'J': 0, 'Q': 1, 'K': 2}\n\n    # Calculate Pot Odds\n    if action == 'call':\n        call_cost = last_raise\n        if current_round == 1:\n            call_cost = 2\n        elif current_round == 2:\n            call_cost = 4\n        # Calculate Pot and Pot Odds\n        pot_odds = call_cost / pot_size\n        hand_strength = rank_order[current_hand_rank] / 2\n        result_score = max(0.0, min(1.0, 1.0 - (hand_strength + pot_odds)))\n\n    elif action == 'raise':\n        if current_raise < 2:\n            raise_cost = last_raise * 2\n            pot_odds = raise_cost / (pot_size + raise_cost)\n            hand_strength = rank_order[current_hand_rank] / 2\n            result_score = max(0.0, min(1.0, hand_strength - pot_odds))\n        else:\n            # Already maximum raises, raise not favorable\n            result_score = 0.0\n\n    elif action == 'fold':\n        # If fold, reward should be zero because it forfeits the round\n        result_score = 0.0\n        \n    else:\n        # Invalid action, return zero\n        result_score = 0.0\n\n    return result_score\n",
        "\ndef score(state: dict, action: str) -> float:\n    \"\"\"\n    Calculate an action-value score for a given game state and action.\n\n    Parameters:\n    state: A dictionary representing the current game state.\n    action: A string representing the planned action (e.g., \"fold\", \"call\", \"raise\").\n\n    Returns:\n    A float representing the probability of winning given the current game state and action.\n    \"\"\"\n\n    # Extract necessary data from state\n    common = state[\"common\"]\n    players = state[\"players\"]\n    current_player_id = common[\"current_player\"]\n    current_player = players[current_player_id]\n\n    # Determine card strength\n    # Assign arbitrary numeric values for card ranks: K > Q > J\n    card_strength = {\"K\": 2, \"Q\": 1, \"J\": 0}\n    \n    # Get the current player's hand rank\n    player_hand_rank = card_strength[current_player[\"facedown_cards\"][\"hand\"][0][\"rank\"]]\n\n    # Get the public card rank, if revealed\n    public_card = common[\"faceup_cards\"][\"public_card\"]\n    public_card_rank = card_strength[public_card[\"rank\"]] if public_card else -1\n\n    # Determine the pot odds\n    pot_contribution = current_player[\"public\"][\"total_pot_contribution\"]\n    total_pot = sum(player[\"public\"][\"total_pot_contribution\"] for player in players)\n    pot_odds = pot_contribution / total_pot if total_pot else 0\n\n    # Determine action factor\n    # Fold results in 0, Call a conservative play, Raise is aggressive\n    action_factor = 0\n    if action == \"call\":\n        action_factor = 0.5\n    elif action == \"raise\":\n        action_factor = 1.0\n    \n    # Determine AggressionFactor based on current round and potential for bluff\n    # More aggressive with stronger perceived hand; more likely to bluff with action potential\n    aggression_factor = 0.5 + (player_hand_rank / 3) + (action_factor / 2)\n\n    # Calculate probability of winning\n    if public_card:\n        # If public card is revealed, calculate based on matching potential\n        if player_hand_rank == public_card_rank:\n            win_probability = 0.9  # Strong likelihood of winning\n        else:\n            win_probability = 0.5 + (player_hand_rank - public_card_rank) / 6\n    else:\n        # Without public card, weigh aggression and potential\n        win_probability = aggression_factor\n\n    # Factor in pot odds if considering calling\n    if action == \"call\":\n        win_probability = min(win_probability + pot_odds, 1.0)\n\n    # Ensure result within bounds and continuous\n    result_score = max(0, min(win_probability, 1))\n    return result_score\n",
        "\ndef score(state: dict, action: dict) -> float:\n    # Extract important information from the state\n    common_info = state.get(\"common\", {})\n    players_info = state.get(\"players\", [])\n    current_round = common_info.get(\"round\", 1)\n    public_card = common_info.get(\"faceup_cards\", {}).get(\"public_card\", None)\n    num_raises = common_info.get(\"num_raises\", 0)\n    current_player = common_info.get(\"current_player\", 0)\n\n    # Extract information about the current player's hand\n    current_player_hand = players_info[current_player][\"facedown_cards\"][\"hand\"][0][\"rank\"]\n\n    # Initial win probability based on hand strength\n    hand_strength = {\"K\": 6, \"Q\": 3, \"J\": 1}\n    win_probability = hand_strength.get(current_player_hand, 0) / sum(hand_strength.values())\n\n    # Adjust probability based on the presence of a public card\n    if public_card:\n        if current_player_hand == public_card.get(\"rank\"):\n            # The player's hand matches the public card\n            win_probability = 1.0\n        else:\n            # The public card does not match the player's hand\n            win_probability *= 0.5\n\n    # Consider the effect of the action planned\n    action_effect = {\n        \"fold\": -0.5,   # Folding drastically reduces winning chances to zero\n        \"call\": 0.0,    # Calling neither increases nor decreases base win probability\n        \"raise\": 0.2    # Raising could indicate strong confidence, slightly increases chance\n    }\n\n    # Adjust for the number of raises, assuming more raises indicates a potentially stronger hand\n    raise_adjustment = num_raises * 0.1\n\n    # Get the type of action as a string\n    action_type = action.get(\"action\", \"\")\n\n    # Calculate final win probability\n    action_score = action_effect.get(action_type, 0)\n    result_score = min(1.0, max(0.0, win_probability + action_score + raise_adjustment))\n\n    return result_score\n"
    ]
}