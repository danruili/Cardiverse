{
    "game_description": "## Refined Ruleset for Card Game: \"Fusion Rummy\"\n\n### 1. **Game State**\n\n#### **Common Information:**\n- **Communal Pool:** Cards that are laid down and visible to all players, used for fusion.\n- **Pot:** Number of counters in the pot visible to all players.\n- **Current Player:** The active player's turn status, with previous actions taken.\n- **Sequence Information:** Current suit being played and its sequence.\n\n#### **Player-Specific Information:**\n- **Public**:\n  - **Fusion Cards:** Displayed unique fusion cards for each player.\n  - **Chips in Front:** If additional chips are anteed due to unequal cards.\n- **Private**:\n  - **Player Hand:** Cards held by the player, visible only to them.\n  - **Special Abilities:** Any special effects granted by fusion cards.\n\n---\n\n### 2. **Card**\n\n#### **Attributes:**\n- **Rank:** K, Q, J, 10, 9, 8, 7, 6, 5, 4, 3, 2, A (with King being high).\n- **Suit:** Hearts, Diamonds, Clubs, Spades.\n\n#### **Special Values:**\n- **Fusion Cards:** Derived from sequences of three consecutive ranks that offer strategic advantages.\n\n---\n\n### 3. **Deck and Initial Dealing**\n\n#### **Deck Composition:**\n- A standard 52-card deck, comprising 13 ranks across 4 suits.\n\n#### **Initial Dealing:**\n- Cards are dealt one at a time starting from the player to the left of the dealer until all cards are allocated. \n- Some players may have more cards than others. Players with fewer cards must ante an additional chip to the pot.\n\n---\n\n### 4. **Legal Action Space**\n\n#### **On a Turn, a Player May:**\n1. **Play a Card:**\n   - Play the next higher card in the current suit in sequence.\n   - Pre-requisite: Card must follow the current suit and sequence.\n2. **Place a Counter:**\n   - Place one counter into the pot if unable or unwilling to play.\n3. **Create a Fusion Card:**\n   - Form a sequence of three consecutive cards solely from their hand.\n   - Added Clarification: Cards used for fusion are removed from the player's hand and displayed publicly, contributing to the player's fusion count.\n4. **Use Fusion Special Ability:**\n   - Activate special abilities provided by previously formed fusion cards during the player's turn.\n\n---\n\n### 5. **Round**\n\n#### **Sequence of Play:**\n1. The player to the dealer's left starts the play by playing a card of choice.\n2. Each subsequent player must follow the sequence:\n   - Play a higher rank of the same suit, OR\n   - Place a counter in the pot if unable or unwilling to play the required card.\n3. Players may form fusion cards from valid sequences purely in their hands.\n4. Continuation until the suit is exhausted, or a player fulfills the fusion card requirement.\n5. Player completing a sequence can start a new suit sequence.\n6. A player wins the game by creating the designated number of fusion cards.\n7. Rounds end when a player creates the required number of fusion cards or all card sequences are exhausted.\n\n#### **Winning Conditions:**\n- The first player to create three unique fusion cards wins the game, immediately ending the current round and ignoring leftover cards.\n\n---\n\n### 6. **Other Game Mechanics & Rules**\n\n- **Reform Initiative:** Upon exhausting a suit sequence, the player may start a new suit.\n- **Fusion Abilities:** Include actions like skip-turn effects, card protection, or counter retrieval from the pot, used during the player's turn.\n- **Card Exhaustion:** If all sequences are exhausted, the round ends normally.\n\n---\n\n### 7. **Player Observation Information**\n\n#### **Visible Information to Each Player:**\n- Their own hand.\n- Communal pool of cards.\n- Current pot chips.\n- Publicly displayed fusion cards and their effects.\n- Actions taken by every player during their turn.\n\n#### **Hidden Information:**\n- Unrevealed card sequences or strategies of other players.\n\n---\n\n### 8. **Payoffs**\n\n#### **End of Round Scoring:**\n- Scoring for rounds via card remnants is nullified if the game ends via fusion victory.\n- In games without an immediate fusion victory, traditional scoring proceeds; 1 point for each card left.\n\n#### **Fusion Bonuses:**\n- Formation of unique and strategic fusion cards that empower players with special actions and directly influence game outcomes. \n\nThis refined version maintains consistency in the rules and resolves previous ambiguities, enhancing the clarity and strategic depth of \"Fusion Rummy.\"",
    "input_description": "Example: \n{\"common\": {\"num_players\": 4, \"current_player\": 2, \"pot\": 4, \"communal_pool\": [{\"rank\": \"J\", \"suit\": \"spades\"}, {\"rank\": \"Q\", \"suit\": \"spades\"}], \"sequence_info\": {\"current_suit\": \"spades\", \"current_sequence\": [\"J\", \"Q\"]}, \"facedown_cards\": {\"stock_size\": 0}, \"is_over\": false, \"winner\": null}, \"players\": [{\"public\": {\"fusion_cards\": [], \"chips_in_front\": 1}}, {\"public\": {\"fusion_cards\": [], \"chips_in_front\": 2}}, {\"public\": {\"fusion_cards\": [], \"chips_in_front\": 1, \"current_player\": true}, \"private\": {\"player_hand\": [{\"rank\": \"5\", \"suit\": \"hearts\"}, {\"rank\": \"7\", \"suit\": \"hearts\"}, {\"rank\": \"K\", \"suit\": \"hearts\"}, {\"rank\": \"4\", \"suit\": \"hearts\"}, {\"rank\": \"3\", \"suit\": \"spades\"}, {\"rank\": \"3\", \"suit\": \"hearts\"}, {\"rank\": \"K\", \"suit\": \"spades\"}, {\"rank\": \"7\", \"suit\": \"diamonds\"}, {\"rank\": \"10\", \"suit\": \"spades\"}, {\"rank\": \"Q\", \"suit\": \"clubs\"}, {\"rank\": \"A\", \"suit\": \"hearts\"}, {\"rank\": \"5\", \"suit\": \"spades\"}, {\"rank\": \"A\", \"suit\": \"diamonds\"}], \"special_abilities\": []}}, {\"public\": {\"fusion_cards\": [], \"chips_in_front\": 0}}], \"recent_history\": [{\"type\": \"action\", \"player_id\": 2, \"action\": {\"action\": \"place_counter\", \"id\": 0}, \"msg\": \"Player 2 decides to: place_counter\"}, {\"type\": \"info\", \"msg\": \"Player 2's action: place_counter.\", \"role\": null}, {\"type\": \"info\", \"msg\": \"Player 2 places a counter into the pot.\", \"role\": null}, {\"type\": \"turn_end\", \"player_id\": 2, \"msg\": \"---------- End of Player 2's turn ----------\"}, {\"type\": \"action\", \"player_id\": 3, \"action\": {\"action\": \"play_card\", \"args\": {\"card\": {\"rank\": \"Q\", \"suit\": \"spades\"}}, \"id\": 0}, \"msg\": \"Player 3 decides to: play_card-(card: Q-spades)\"}, {\"type\": \"info\", \"msg\": \"Player 3's action: play_card.\", \"role\": null}, {\"type\": \"info\", \"msg\": \"Player 3 plays Q-spades.\", \"role\": null}, {\"type\": \"turn_end\", \"player_id\": 3, \"msg\": \"---------- End of Player 3's turn ----------\"}, {\"type\": \"action\", \"player_id\": 0, \"action\": {\"action\": \"place_counter\", \"id\": 0}, \"msg\": \"Player 0 decides to: place_counter\"}, {\"type\": \"info\", \"msg\": \"Player 0's action: place_counter.\", \"role\": null}, {\"type\": \"info\", \"msg\": \"Player 0 places a counter into the pot.\", \"role\": null}, {\"type\": \"turn_end\", \"player_id\": 0, \"msg\": \"---------- End of Player 0's turn ----------\"}, {\"type\": \"action\", \"player_id\": 1, \"action\": {\"action\": \"place_counter\", \"id\": 0}, \"msg\": \"Player 1 decides to: place_counter\"}, {\"type\": \"info\", \"msg\": \"Player 1's action: place_counter.\", \"role\": null}, {\"type\": \"info\", \"msg\": \"Player 1 places a counter into the pot.\", \"role\": null}], \"legal_actions\": [{\"action\": \"play_card\", \"args\": {\"card\": {\"rank\": \"K\", \"suit\": \"spades\"}}, \"id\": 0}, {\"action\": \"create_fusion_card\", \"args\": {\"cards\": [{\"rank\": \"3\", \"suit\": \"hearts\"}, {\"rank\": \"4\", \"suit\": \"hearts\"}, {\"rank\": \"5\", \"suit\": \"hearts\"}]}, \"id\": 1}]}\n\nExplanation: \n{\"common\": \"A dictionary holding common game-related information shared across all players.\", \"common.num_players\": \"An integer representing the total number of players participating in the game.\", \"common.current_player\": \"An integer index of the player whose turn it is currently in the game.\", \"common.pot\": \"An integer representing the total number of chips currently in the pot.\", \"common.communal_pool\": \"A list of card dictionaries representing the cards currently in the communal pool, which are visible to all players.\", \"common.sequence_info\": \"A dictionary containing information about the current card sequence that is being played.\", \"common.sequence_info.current_suit\": \"A string representing the suit of the current card sequence in play.\", \"common.sequence_info.current_sequence\": \"A list of strings representing the ranks of cards in the current sequence played.\", \"common.facedown_cards\": \"A dictionary containing information about the facedown cards remaining in the game.\", \"common.facedown_cards.stock_size\": \"An integer indicating the number of cards remaining in the facedown stock pile.\", \"common.is_over\": \"A boolean indicating whether the game has ended (true) or is still ongoing (false).\", \"common.winner\": \"An integer or null representing the index of the winning player, or null if there is no winner yet.\", \"players\": \"A list containing dictionaries of individual player state information.\", \"players[N].public\": \"A dictionary holding public information about player N that is visible to all players.\", \"players[N].public.fusion_cards\": \"A list of lists representing the fusion cards created by player N. Each sublist is a set of three cards forming a valid fusion.\", \"players[N].public.chips_in_front\": \"An integer representing the number of chips player N currently has in front of them, visible to all players.\", \"players[N].private\": \"A dictionary containing private information about player N that is only visible to this player.\", \"players[N].private.player_hand\": \"A list of card dictionaries representing the player's current hand of cards.\", \"players[N].private.special_abilities\": \"A list of strings representing the special abilities available to the player.\", \"recent_history\": \"A list of dictionaries representing actions and messages from recent turns, including actions taken by players and informational messages.\", \"recent_history[N].type\": \"A string indicating the type of event, such as 'action', 'info', or 'turn_end'.\", \"recent_history[N].player_id\": \"An integer indicating which player performed the action; used in events of type 'action' or 'turn_end'.\", \"recent_history[N].action\": \"A dictionary providing details about the action taken, present when the type of event is 'action'.\", \"recent_history[N].msg\": \"A string containing a descriptive message about the event or action.\", \"legal_actions\": \"A list of dictionaries representing the legal actions available to the current player.\", \"legal_actions[N].action\": \"A string specifying the type of action that the current player can take, such as 'play_card' or 'create_fusion_card'.\", \"legal_actions[N].args\": \"A dictionary containing arguments related to the action, such as card information for 'play_card'.\"}",
    "policy_list": [
        "**Sequence Optimization**\nFocus on aligning and arranging your hand to maximize the potential to form sequences that can be played consecutively using the current suit, thus exhausting your hand efficiently.",
        "**Fusion Focus**\nPrioritize forming fusion cards by looking for three consecutive ranks in your hand, even if it might mean holding back from playing an immediate card.",
        "**Aggressive Play**\nExhaust opponent resources by consistently playing cards of the current sequence, forcing other players to contribute counters when they can't play.",
        "**Resource Management**\nMonitor and manage your chips and fusion cards optimally, ensuring resilience and scalability, ensuring long-term adaptability and power retention."
    ],
    "code": [
        "\ndef score(state: dict, action: dict) -> float:\n    def rank_to_value(rank):\n        return '23456789TJQKA'.index(rank) + 2\n\n    def evaluate_hand_potential(player_hand, current_suit, current_sequence):\n        # Assessing how many sequences can be potentially formed and continued\n        same_suit_cards = [card for card in player_hand if card['suit'] == current_suit]\n        highest_in_sequence_value = rank_to_value(current_sequence[-1]) if current_sequence else 0\n        potential = 0\n        for card in same_suit_cards:\n            if rank_to_value(card['rank']) > highest_in_sequence_value:\n                potential += 1\n        return potential / len(player_hand) if player_hand else 0\n\n    def calculate_potential_fusion(hand):\n        # Check all possible 3 card sequences for potential fusion\n        ranks = sorted([rank_to_value(card['rank']) for card in hand])\n        fusion_potential = 0\n        for i in range(len(ranks) - 2):\n            if ranks[i+1] == ranks[i] + 1 and ranks[i+2] == ranks[i] + 2:\n                fusion_potential += 1\n        return fusion_potential / (len(hand) - 2) if len(hand) > 2 else 0\n\n    common = state[\"common\"]\n    players = state[\"players\"]\n    \n    current_player = common[\"current_player\"]\n    player_info = players[current_player]\n\n    player_hand = player_info[\"private\"][\"player_hand\"]\n    current_sequence = common[\"sequence_info\"][\"current_sequence\"]\n    current_suit = common[\"sequence_info\"][\"current_suit\"]\n\n    # Calculate baseline score based on current player's hand potential\n    play_card_potential = evaluate_hand_potential(player_hand, current_suit, current_sequence)\n    fusion_potential = calculate_potential_fusion(player_hand)\n\n    base_score = (play_card_potential + fusion_potential) / 2\n\n    # Interpret and score the specific action\n    if action[\"action\"] == \"play_card\":\n        card = action[\"args\"][\"card\"]\n        if card[\"suit\"] == current_suit and rank_to_value(card[\"rank\"]) == rank_to_value(current_sequence[-1]) + 1:\n            action_score = 0.2  # Deliberately lower to increase when action is better\n        else:\n            action_score = -0.2\n\n    elif action[\"action\"] == \"create_fusion_card\":\n        action_score = 0.4  # Weight for strategic fusion formation\n\n    else:\n        action_score = 0  # Neutral score for non-beneficial actions\n\n    # Combine base score with action relevance\n    result_score = min(max(base_score + action_score, 0), 1)\n    \n    return result_score\n",
        "\ndef score(state: dict, action: dict) -> float:\n    \"\"\"\n    Calculate the action-value score based on the current game state and the planned action.\n    This score serves as an estimate of the probability of winning the game.\n    The score values are in the range [0, 1] with a higher score indicating a higher chance of winning.\n\n    Args:\n    - state: A dictionary representing the current game state.\n    - action: A dictionary representing the action being evaluated.\n\n    Returns:\n    - A float that represents the estimated probability of winning.\n    \"\"\"\n    \n    # Extract necessary information from the state\n    current_player_idx = state['common']['current_player']\n    player_state = state['players'][current_player_idx]\n    player_hand = player_state['private']['player_hand']\n    fusion_cards = player_state['public']['fusion_cards']\n    num_fusion_cards = len(fusion_cards)\n    \n    # Define rank order for scoring\n    rank_order = {'A': 1, '2': 2, '3': 3, '4': 4, '5': 5, \n                  '6': 6, '7': 7, '8': 8, '9': 9, '10': 10, \n                  'J': 11, 'Q': 12, 'K': 13}\n    \n    max_fusion_cards_needed = 3\n\n    # Extract action details\n    action_type = action['action']\n    action_args = action.get('args', {})\n\n    # Initial reward based on existing fusion cards\n    reward = num_fusion_cards / max_fusion_cards_needed\n    \n    # Evaluate the action\n    if action_type == 'create_fusion_card':\n        # Reward for creating fusion cards\n        potential_fusion_cards = action_args['cards']\n        if len(potential_fusion_cards) == 3:\n            # Verify consecutiveness in ranks\n            sorted_cards = sorted(potential_fusion_cards, key=lambda x: rank_order[x['rank']])\n            if (rank_order[sorted_cards[1]['rank']] == rank_order[sorted_cards[0]['rank']] + 1 and\n                rank_order[sorted_cards[2]['rank']] == rank_order[sorted_cards[1]['rank']] + 1):\n                reward += 0.5\n\n    elif action_type == 'play_card':\n        # Slight incentive for playing cards to advance sequence (contributing to immediate tactical advantage)\n        if 'card' in action_args:\n            played_card = action_args['card']\n            current_sequence = state['common']['sequence_info']['current_sequence']\n            current_rank = current_sequence[-1] if current_sequence else None\n            \n            if current_rank and rank_order[played_card['rank']] > rank_order[current_rank]:\n                reward += 0.1\n\n    # Add small hook for potential fusion and card usage insights\n    if any(rank_order[c['rank']] < 5 for c in player_hand):\n        reward = min(reward + 0.05, 1.0)\n\n    # Ensure reward is within bounds\n    result_score = max(0.0, min(reward, 1.0))\n    \n    return result_score\n",
        "\ndef score(state: dict, action: dict) -> float:\n    # Extract common state information\n    common_info = state[\"common\"]\n    players_info = state[\"players\"]\n    current_player_idx = common_info[\"current_player\"]\n    player_hand = players_info[current_player_idx][\"private\"][\"player_hand\"]\n    pot = common_info[\"pot\"]\n    \n    # Extract action information\n    action_type = action[\"action\"]\n    action_args = action.get(\"args\", {})\n\n    # Calculate potential score\n    score = 0.5  # default neutral score\n\n    if action_type == \"play_card\":\n        card_to_play = action_args[\"card\"]\n        # Favor playing higher cards in the current suit\n        if card_to_play[\"suit\"] == common_info[\"sequence_info\"][\"current_suit\"]:\n            card_in_sequence = card_to_play[\"rank\"] in common_info[\"sequence_info\"][\"current_sequence\"]\n            score += 0.2 if card_in_sequence else 0\n\n        # Favor aggressive action consistent with aggressive strategy: play cards if able\n        score += 0.2\n    \n    elif action_type == \"create_fusion_card\":\n        cards_for_fusion = action_args[\"cards\"]\n\n        # If forming a fusion card involves cards that were hard to play in the sequence\n        sequence_suit = common_info[\"sequence_info\"][\"current_suit\"]\n        involves_difficult_play = any(card[\"suit\"] != sequence_suit for card in cards_for_fusion)\n        \n        # Encourage forming fusion cards, especially with difficult-to-play cards\n        score += 0.3 if involves_difficult_play else 0.1\n    \n    # Discourage placing a counter unless necessary\n    if action_type == \"place_counter\":\n        score -= 0.3\n    \n    # Make score more continuous based on pot size\n    pot_factor = 1 - (0.05 * pot)  # Less attractive to place counters as pot grows\n    score *= pot_factor\n    \n    # Ensure the score is bounded between 0 and 1\n    result_score = min(max(score, 0.0), 1.0)\n\n    return result_score\n",
        "\ndef score(state: dict, action: dict) -> float:\n    # Extract necessary information from the game state\n    common = state['common']\n    players = state['players']\n    current_player_index = common['current_player']\n    current_player = players[current_player_index]\n    player_hand = current_player['private']['player_hand']\n    legal_actions = state['legal_actions']\n    fusion_count = len(current_player['public']['fusion_cards'])\n    \n    # Define base probabilities and constants\n    max_possible_fusion = 3\n    base_probability = 0.1  # Starting base chance\n    fusion_card_bonus = 0.3  # Bonus for successfully creating a fusion card\n    chip_penalty = 0.05  # Penalty for having to place a counter\n    play_bonus = 0.2  # Bonus for playing a card and proceeding the sequence\n    \n    # Start with the base probability\n    result_score = base_probability\n    \n    # Calculate the potential impact of the action\n    if action['action'] == 'create_fusion_card':\n        result_score += fusion_card_bonus\n    \n    if action['action'] == 'play_card':\n        card_to_play = action['args']['card']\n        # Check if the card continues the sequence correctly\n        current_sequence = common['sequence_info']['current_sequence']\n        if card_to_play['rank'] in current_sequence:\n            result_score += play_bonus\n    \n    # Penalty if the player had no suitable card and placed a counter (if applied)\n    if action['action'] == 'place_counter':\n        result_score -= chip_penalty\n    \n    # Consider the number of fusion cards already made\n    result_score += (fusion_count / max_possible_fusion) * (1 - result_score)\n    \n    # Clamp the result score between 0 and 1\n    result_score = max(0, min(result_score, 1))\n    \n    return result_score\n"
    ]
}