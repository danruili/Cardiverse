{
    "game_description": "Many trick-taking games are not directly related to Bridge or Whist. Perhaps the foremost one is Hearts, which is truly one of the greatest card games ever devised for four players, each playing individually.\n\n### The Pack\n\nThe standard 52-card pack is used.\n\nShop Bicycle Hearts Playing Cards\n\n### Object of the Game\n\nTo be the player with the lowest score at the end of the game. When one player hits the agreed-upon score or higher, the game ends; and the player with the lowest score wins.\n\n### Card Values/scoring\n\nAt the end of each hand, players count the number of hearts they have taken as well as the queen of spades, if applicable. Hearts count as one point each and the queen counts 13 points.\n\nEach heart - 1 point\n\nThe Q - 13 points\n\nThe aggregate total of all scores for each hand must be a multiple of 26.\n\nThe game is usually played to 100 points (some play to 50).\n\nWhen a player takes all 13 hearts and the queen of spades in one hand, instead of losing 26 points, that player scores zero and each of his opponents score an additional 26 points.\n\n### The Deal\n\nDeal the cards one at a time, face down, clockwise. In a four-player game, each is dealt 13 cards; in a three-player game, the 2 of diamonds should be removed, and each player gets 17 cards; in a five-player game, the 2 of clubs should be removed so that each player will get 10 cards.\n\n### The Play\n\nThe player holding the 2 of clubs after the pass makes the opening lead. If the 2 has been removed for the three handed game, then the 3 of clubs is led.\n\nEach player must follow suit if possible. If a player is void of the suit led, a card of any other suit may be discarded. However, if a player has no clubs when the first trick is led, a heart or the queen of spades cannot be discarded. The highest card of the suit led wins a trick and the winner of that trick leads next. There is no trump suit.\n\nThe winner of the trick collects it and places it face down. Hearts may not be led until a heart or the queen of spades has been discarded. The queen does not have to be discarded at the first opportunity.\n\nThe queen can be led at any time.",
    "input_description": "Example: \n{\"common\": {\"num_players\": 4, \"current_player\": 2, \"direction\": 1, \"winner\": null, \"is_over\": false, \"scores\": [0, 0, 0, 0], \"hearts_broken\": false, \"facedown_cards\": {\"deck_size\": 0}, \"faceup_cards\": {\"current_trick\": [{\"player\": 0, \"card\": {\"rank\": \"Q\", \"suit\": \"diamonds\"}}, {\"player\": 1, \"card\": {\"rank\": \"3\", \"suit\": \"diamonds\"}}], \"trick_history\": [[{\"player\": 3, \"card\": {\"rank\": \"2\", \"suit\": \"clubs\"}}, {\"player\": 0, \"card\": {\"rank\": \"9\", \"suit\": \"clubs\"}}, {\"player\": 1, \"card\": {\"rank\": \"8\", \"suit\": \"clubs\"}}, {\"player\": 2, \"card\": {\"rank\": \"3\", \"suit\": \"clubs\"}}]]}}, \"players\": [{\"public\": {\"tricks_won_count\": 1}, \"facedown_cards\": {\"hand_size\": 11}, \"faceup_cards\": {\"collected_cards\": [{\"rank\": \"2\", \"suit\": \"clubs\"}, {\"rank\": \"9\", \"suit\": \"clubs\"}, {\"rank\": \"8\", \"suit\": \"clubs\"}, {\"rank\": \"3\", \"suit\": \"clubs\"}]}}, {\"public\": {\"tricks_won_count\": 0}, \"facedown_cards\": {\"hand_size\": 11}, \"faceup_cards\": {\"collected_cards\": []}}, {\"public\": {\"tricks_won_count\": 0, \"current_player\": true}, \"private\": {}, \"facedown_cards\": {\"hand\": [{\"rank\": \"3\", \"suit\": \"spades\"}, {\"rank\": \"2\", \"suit\": \"diamonds\"}, {\"rank\": \"Q\", \"suit\": \"spades\"}, {\"rank\": \"K\", \"suit\": \"clubs\"}, {\"rank\": \"6\", \"suit\": \"clubs\"}, {\"rank\": \"K\", \"suit\": \"diamonds\"}, {\"rank\": \"2\", \"suit\": \"hearts\"}, {\"rank\": \"5\", \"suit\": \"diamonds\"}, {\"rank\": \"4\", \"suit\": \"clubs\"}, {\"rank\": \"4\", \"suit\": \"hearts\"}, {\"rank\": \"K\", \"suit\": \"spades\"}, {\"rank\": \"J\", \"suit\": \"clubs\"}]}, \"faceup_cards\": {\"collected_cards\": []}}, {\"public\": {\"tricks_won_count\": 0}, \"facedown_cards\": {\"hand_size\": 12}, \"faceup_cards\": {\"collected_cards\": []}}], \"recent_history\": [{\"type\": \"action\", \"player_id\": 2, \"action\": {\"action\": \"play\", \"args\": {\"rank\": \"3\", \"suit\": \"clubs\"}, \"id\": 2}, \"msg\": \"Player 2 decides to: play-(rank: 3, suit: clubs)\"}, {\"type\": \"info\", \"msg\": \"Player 2 plays 3-clubs.\", \"role\": null}, {\"type\": \"info\", \"msg\": \"Player 0 wins the trick and will lead the next.\", \"role\": null}, {\"type\": \"turn_end\", \"player_id\": 2, \"msg\": \"---------- End of Player 2's turn ----------\"}, {\"type\": \"action\", \"player_id\": 0, \"action\": {\"action\": \"play\", \"args\": {\"rank\": \"Q\", \"suit\": \"diamonds\"}, \"id\": 8}, \"msg\": \"Player 0 decides to: play-(rank: Q, suit: diamonds)\"}, {\"type\": \"info\", \"msg\": \"Player 0 plays Q-diamonds.\", \"role\": null}, {\"type\": \"turn_end\", \"player_id\": 0, \"msg\": \"---------- End of Player 0's turn ----------\"}, {\"type\": \"action\", \"player_id\": 1, \"action\": {\"action\": \"play\", \"args\": {\"rank\": \"3\", \"suit\": \"diamonds\"}, \"id\": 2}, \"msg\": \"Player 1 decides to: play-(rank: 3, suit: diamonds)\"}, {\"type\": \"info\", \"msg\": \"Player 1 plays 3-diamonds.\", \"role\": null}], \"legal_actions\": [{\"action\": \"play\", \"args\": {\"rank\": \"2\", \"suit\": \"diamonds\"}, \"id\": 0}, {\"action\": \"play\", \"args\": {\"rank\": \"K\", \"suit\": \"diamonds\"}, \"id\": 1}, {\"action\": \"play\", \"args\": {\"rank\": \"5\", \"suit\": \"diamonds\"}, \"id\": 2}]}\n\nExplanation: \n{\"common\": \"A dictionary containing information shared among all players about the state of the game.\", \"common.num_players\": \"The number of players in the game (integer).\", \"common.current_player\": \"The player who is to play next, represented as an integer index (0-based) identifying the player.\", \"common.direction\": \"The direction of play, 1 typically indicates clockwise (positive direction) (integer).\", \"common.winner\": \"The player who won the game (None indicates no winner yet) (nullable integer).\", \"common.is_over\": \"A boolean indicating if the game is over (true if yes, false if no).\", \"common.scores\": \"A list of integers representing the scores of each player in the game, indexed by player.\", \"common.hearts_broken\": \"A boolean indicating if hearts have been broken (true if yes, false if no).\", \"common.facedown_cards.deck_size\": \"The number of cards remaining in the deck (integer).\", \"common.faceup_cards.current_trick\": \"A list representing the current trick, detailing which players have played what cards, each entry is a dictionary with 'player' (integer) and 'card' (dictionary with 'rank' and 'suit').\", \"common.faceup_cards.trick_history\": \"A list of lists showing the history of all completed tricks, each trick shown as a list of dictionaries, where each dictionary contains 'player' (integer) and 'card' (dictionary with 'rank' and 'suit').\", \"players\": \"A list containing individual dictionaries for each player, indexed by player number (0-based).\", \"players[].public.tricks_won_count\": \"The number of tricks won by this player (integer).\", \"players[].facedown_cards.hand_size\": \"The number of cards remaining in this player's hand (integer).\", \"players[].faceup_cards.collected_cards\": \"A list of cards (each a dictionary with 'rank' and 'suit') that this player has won in previous tricks.\", \"players[2].public.current_player\": \"Boolean to indicate if this player is the current player (true if yes, only for the player whose turn it is).\", \"players[2].facedown_cards.hand\": \"A list of dictionaries, each containing 'rank' and 'suit', representing the cards currently in this player's hand. Only shown for the current player.\", \"recent_history\": \"A list of dictionaries logging the recent actions and events in the game, detailing actions by player ID and messages.\", \"recent_history[].type\": \"The type of entry in the history log. It can be 'action', 'info', or 'turn_end'.\", \"recent_history[].player_id\": \"The ID of a player associated with an action or turn end event (integer).\", \"recent_history[].action\": \"A dictionary detailing an action taken by a player; includes the action type and the arguments ('rank' and 'suit') of the card played.\", \"recent_history[].msg\": \"A descriptive string message detailing the particular event or state change.\", \"recent_history[].role\": \"The role of the message, usually null unless specified differently.\", \"legal_actions\": \"A list of allowable actions for the current player; each action is a dictionary containing 'action' type and 'args', which further details the 'rank' and 'suit' of the card that can be played.\"}",
    "policy_list": [
        "**Risk of Taking Heart**\nThis metric assesses the potential risk of collecting a heart card in a trick based on the current game state. It considers the likelihood of opponents playing hearts or the queen of spades and the player's ability to follow or avoid these suits.",
        "**Potential for Shooting the Moon**\nThis metric measures the potential for a player to collect all heart cards and the queen of spades ('shooting the moon'). It evaluates the player's current hand, the cards already played, and the remaining cards to estimate the feasibility of achieving this state.",
        "**Control of the Lead**\nThis metric evaluates the strategic advantage of controlling the lead in the current hand. It considers the player's ability to dictate the suit of play and force opponents into disadvantageous plays based on known game history and remaining cards.",
        "**Suit Shortage**\nThis metric assesses the player's shortage in each suit, indicating liability to void in a suit. A higher shortage may allow strategic discard opportunities or a safe disposition when lacking the leading suit, affecting both immediate and strategic actions."
    ],
    "code": [
        "\ndef score(state: dict, action: dict) -> float:\n    \"\"\"\n    Estimate the probability of winning the game given the current state and a planned action.\n    \n    Parameters:\n    - state: A dictionary containing the current game state.\n    - action: A dictionary representing the action to be evaluated, including 'rank' and 'suit'.\n    \n    Returns:\n    - A float value in the range [0, 1] representing the estimated probability of winning.\n    \"\"\"\n    \n    # Initialize a base score\n    base_score = 0.5\n\n    # Initialize risk score\n    risk_score = 0\n\n    # Check if hearts have been broken\n    hearts_broken = state['common']['hearts_broken']\n    \n    # Retrieve information about the current player\n    current_player_id = state['common']['current_player']\n    current_player_hand = state['players'][current_player_id]['facedown_cards']['hand']\n    \n    # Evaluate risk based on current trick and player's hand\n    current_trick_suit = state['common']['faceup_cards']['current_trick'][0]['card']['suit'] if state['common']['faceup_cards']['current_trick'] else None\n    \n    # If the current trick suit is not hearts, calculate potential risk based on hearts and \n    # queen of spades in player's hand\n    for card in current_player_hand:\n        if card['suit'] == 'hearts':\n            risk_score += 0.1  # risk for having hearts\n        if card['rank'] == 'Q' and card['suit'] == 'spades':\n            risk_score += 0.3  # risk for having Queen of Spades\n    \n    # Modify risk based on hearts broken status\n    if hearts_broken:\n        risk_score *= 0.8  # reduce risk since hearts are already broken\n    \n    # Modify risk if leading\n    if len(state['common']['faceup_cards']['current_trick']) == 0:\n        # Player is leading, calculate potential for others to play high risk cards\n        potential_high_risk = any(card['suit'] == 'hearts' or (card['rank'] == 'Q' and card['suit'] == 'spades') for card in current_player_hand)\n        if potential_high_risk:\n            risk_score += 0.15  # increase risk score if leading with high-risk cards\n\n    # Factor played action into the score\n    action_card = action['args']\n    if action_card['rank'] == 'Q' and action_card['suit'] == 'spades':\n        risk_score += 0.3  # high risk for playing Queen of Spades\n    if action_card['suit'] == 'hearts':\n        risk_score += 0.1  # additional risk for playing hearts\n    \n    # Adjust the base score based on calculated risk\n    result_score = base_score - risk_score\n    \n    # Ensure the score is within [0, 1]\n    result_score = max(0, min(1, result_score))\n    \n    return result_score\n",
        "\ndef score(state: dict, action: dict) -> float:\n    # Extract necessary information from the input state\n    common_state = state['common']\n    player_state = state['players'][common_state['current_player']]\n    current_hand = player_state['facedown_cards']['hand']\n    collected_cards = player_state['faceup_cards']['collected_cards']\n    \n    # Define action parameters\n    action_rank = action['args']['rank']\n    action_suit = action['args']['suit']\n    \n    # Initial evaluation parameters\n    hearts_in_hand = 0\n    queen_spades_in_hand = False\n    high_card_count = 0\n    expected_points = 0\n    \n    # Evaluate player's hand for potential to shoot the moon\n    for card in current_hand:\n        rank, suit = card['rank'], card['suit']\n        if suit == 'hearts':\n            hearts_in_hand += 1\n        if rank == 'Q' and suit == 'spades':\n            queen_spades_in_hand = True\n        if rank in ['10', 'J', 'Q', 'K', 'A']:\n            high_card_count += 1\n    \n    # Calculate expected points after taking the given action\n    if action_suit == 'hearts':\n        hearts_in_hand -= 1  # Playing a heart\n    if action_rank == 'Q' and action_suit == 'spades':\n        queen_spades_in_hand = False  # Playing the queen of spades\n    \n    # Assess collection of cards\n    for card in collected_cards:\n        rank, suit = card['rank'], card['suit']\n        if suit == 'hearts':\n            expected_points += 1\n        if rank == 'Q' and suit == 'spades':\n            expected_points += 13\n\n    # Evaluation criteria for shooting the moon\n    expected_hearts_tally = hearts_in_hand + sum(1 for card in collected_cards if card['suit'] == 'hearts')\n    has_all_hearts = expected_hearts_tally == 13\n    has_queen_and_ability_to_shoot = queen_spades_in_hand or any(card for card in current_hand if card['rank'] == 'A' and card['suit'] == 'spades')\n    \n    if has_all_hearts and (has_queen_and_ability_to_shoot or queen_spades_in_hand):\n        return 1.0  # Maximum score for high potential of shooting the moon\n    \n    # Compute potential score based on high cards and remaining hearts\n    potential_score = (high_card_count + hearts_in_hand) / max(1, len(current_hand))\n    \n    # Return a normalized score reflecting probability to win\n    result_score = max(0.0, min(1.0, potential_score / 4.0))\n    \n    return result_score\n",
        "\ndef score(state: dict, action: dict) -> float:\n    # Initialize parameters\n    num_players = state[\"common\"][\"num_players\"]\n    current_player = state[\"common\"][\"current_player\"]\n    hearts_broken = state[\"common\"][\"hearts_broken\"]\n    scores = state[\"common\"][\"scores\"]\n    current_trick = state[\"common\"][\"faceup_cards\"][\"current_trick\"]\n    trick_history = state[\"common\"][\"faceup_cards\"][\"trick_history\"]\n    players_info = state[\"players\"]\n    current_hand = players_info[current_player][\"facedown_cards\"][\"hand\"]\n    \n    # Proposed action card\n    action_card = action[\"args\"]\n\n    # Calculate risk based on scores\n    max_score = max(scores) if scores else 100\n    score_risk = 1 - (scores[current_player] / max_score if max_score > 0 else 1)\n\n    def card_strength(card, cards):\n        \"\"\"Calculate a relative strength of a card within a given set of cards.\"\"\"\n        rank_order = {'2': 2, '3': 3, '4': 4, '5': 5, '6': 6, '7': 7, '8': 8, '9': 9, '10': 10, 'J': 11, 'Q': 12, 'K': 13, 'A': 14}\n        sorted_cards = sorted(cards, key=lambda c: rank_order[c[\"rank\"]])\n        position = sorted_cards.index(card)\n        strength = position / (len(sorted_cards) - 1) if len(sorted_cards) > 1 else 1\n        return strength\n\n    # Assess control of the lead\n    lead_control = 0\n    if not current_trick:\n        # Start of a new trick, consider the cards in hand for leading\n        lead_control = card_strength(action_card, current_hand)\n    else:\n        # Assess based on the current trick\n        current_suit = current_trick[0][\"card\"][\"suit\"]\n        matching_cards = [card for card in current_hand if card[\"suit\"] == current_suit]\n        \n        if matching_cards:\n            # More control if the action card is the strongest among the same suit\n            lead_control = card_strength(action_card, matching_cards + [card[\"card\"] for card in current_trick])\n        else:\n            # Control depends on avoiding penalty cards\n            if action_card[\"suit\"] == \"spades\" and action_card[\"rank\"] == \"Q\":\n                lead_control = 0  # Avoid playing Queen of Spades\n            elif action_card[\"suit\"] == \"hearts\":\n                lead_control = 0.2  # Avoid breaking hearts\n            else:\n                lead_control = 0.5  # Playing an off-suit card\n\n    # Evaluate the reward score\n    result_score = min(1, max(0, 0.5 * score_risk + 0.5 * lead_control))\n\n    return result_score\n",
        "\ndef score(state: dict, action: dict) -> float:\n    current_player_index = state['common']['current_player']\n    current_player_hand = state['players'][current_player_index]['facedown_cards']['hand']\n    targeted_card = action['args']\n\n    # Calculate suit shortage factor\n    suit_counts = {'clubs': 0, 'diamonds': 0, 'hearts': 0, 'spades': 0}\n    for card in current_player_hand:\n        suit_counts[card['suit']] += 1\n    shortages = [13 - count for count in suit_counts.values()]\n    suit_shortage_score = sum(shortages) / 52  # Normalize by maximum possible shortage\n\n    # Start with a basic score based on suit shortage\n    score = suit_shortage_score\n\n    current_trick = state['common']['faceup_cards']['current_trick']\n    \n    if current_trick:\n        leading_suit = current_trick[0]['card']['suit']\n        can_follow_suit = any(card['suit'] == leading_suit for card in current_player_hand)\n\n        # Adjust scores based on the action planned\n        if not can_follow_suit and targeted_card['suit'] == 'hearts':\n            score += 0.2  # Slightly encourage breaking hearts\n\n        if can_follow_suit and targeted_card['suit'] == leading_suit:\n            if targeted_card['rank'] == 'Q' and targeted_card['suit'] == 'spades':\n                score -= 0.4  # Discourage playing the queen of spades unless strategic\n    else:\n        can_follow_suit = False  # Default when there is no current trick\n\n    # Factor in current scores\n    current_scores = state['common']['scores']\n    if max(current_scores) >= 100:\n        score += (100 - current_scores[current_player_index]) / 100\n\n    # Ensure the score is between 0 and 1\n    result_score = max(0.0, min(1.0, score))\n    return result_score\n"
    ]
}