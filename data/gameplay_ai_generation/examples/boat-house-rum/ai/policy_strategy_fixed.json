{
    "game_description": "### Rank of Cards\n\nK (high), Q, J, 10, 9, 8, 7, 6, 5, 4, 3, 2, A. (In many forms of Rummy, the ace may rank either high or low).\n\n### The Deal\n\nDealer gives one card at a time face down, beginning with the player on the left. When two people play, each person gets 10 cards. When three or four people play, each receives seven cards; when five or six play, each receives six cards. The remaining cards are placed face down on the table, forming the stock.\n\nThe top card of the stock is turned face up and becomes the upcard. It is placed next to the stock to start the discard pile.\n\nWhen two people play, the winner of each hand deals the next. When more than two play, the deal passes to next the player on the left.\n\n### Object of the Game\n\nEach player tries to form matched sets consisting of groups of three or four of a kind, or sequences of three or more cards of the same suit.\n\nAn ace counts either high or low in a sequence, and sequences may go round the corner as in K, A, 2, or A, K, Q.\n\n### The Play\n\nBeginning with the player to the left of the dealer, each player in turn may draw two cards from the stock or, before drawing those cards, two cards from the top of the discard pile. Then the player discards only one card. Play does not end until a player can lay down their entire hand at once.\n\nThe player may also lie down on the table, face up, any meld (matched set). If the player does not wish to lay down a meld, they discard one card, face up, onto the discard pile. If the player has drawn from the discard pile, they may not discard the same card on that turn.\n\n### Laying Off\n\nA player may add one or more from their hand to any matched set already shown on the table. Thus, if threes are showing, they may add the fourth three; if 10, 9, 8 are showing, he may add J, or Q, J, 7, or 7, 6.\n\n### Going Out\n\nWhen a player gets rid of all of their cards, they win the game.\n\nIf the last card of the stock has been drawn and no player has gone out, the next player in turn may either take the top of the discard pile, or may turn the discard pile over to form a new stock (without shuffling it) and draw the top card. Play then proceeds as before.\n\n### How to Keep Score\n\nA player pays only for cards in their hand, which does not form matched sets. A player pays the pip value of all unmatched cards, with the ace counting as 11 points\n\nA player goes \"rummy\" when they get rid of all cards in their hand at once, without previously having put down or laid off any cards. In this event, every other player pays double - twice what their opponents would otherwise owe.",
    "input_description": "Example: \n{\"common\": {\"num_players\": 3, \"current_player\": 0, \"winner\": null, \"has_drawn_cards_this_turn\": false, \"is_over\": false, \"faceup_cards\": {\"discard_pile\": [{\"rank\": \"4\", \"suit\": \"clubs\"}, {\"rank\": \"5\", \"suit\": \"hearts\"}]}, \"facedown_cards\": {\"stock_size\": 26}}, \"players\": [{\"public\": {\"score\": 0, \"current_player\": true}, \"faceup_cards\": {\"melds\": []}, \"facedown_cards\": {\"hand\": [{\"rank\": \"Q\", \"suit\": \"clubs\"}, {\"rank\": \"Q\", \"suit\": \"diamonds\"}, {\"rank\": \"5\", \"suit\": \"diamonds\"}, {\"rank\": \"J\", \"suit\": \"hearts\"}, {\"rank\": \"2\", \"suit\": \"hearts\"}, {\"rank\": \"6\", \"suit\": \"clubs\"}, {\"rank\": \"2\", \"suit\": \"spades\"}, {\"rank\": \"5\", \"suit\": \"spades\"}], \"recent_discard_draw\": []}}, {\"public\": {\"score\": 0}, \"faceup_cards\": {\"melds\": []}, \"facedown_cards\": {\"hand_size\": 8, \"recent_discard_draw_size\": 0}}, {\"public\": {\"score\": 0}, \"faceup_cards\": {\"melds\": []}, \"facedown_cards\": {\"hand_size\": 8, \"recent_discard_draw_size\": 0}}], \"legal_actions\": [{\"action\": \"draw\", \"args\": {\"source\": \"stock\"}, \"id\": 0}, {\"action\": \"draw\", \"args\": {\"source\": \"discard_pile\"}, \"id\": 1}]}\n\nExplanation: \n{\"common\": {\"num_players\": \"The total number of players participating in the game.\", \"current_player\": \"The index of the player whose turn it is currently.\", \"winner\": \"The index of the player who has won the game, or null if there is no winner yet.\", \"has_drawn_cards_this_turn\": \"A boolean indicating whether the current player has drawn cards during their current turn.\", \"is_over\": \"A boolean indicating if the game has ended.\", \"faceup_cards\": {\"discard_pile\": \"A list of cards that are currently in the discard pile, visible to all players.\"}, \"facedown_cards\": {\"stock_size\": \"The number of cards remaining in the stock pile, which is not visible to players.\"}}, \"players\": [{\"public\": {\"score\": \"The player's score, which is publicly visible.\", \"current_player\": \"A boolean indicating if this player is the current player.\"}, \"faceup_cards\": {\"melds\": \"A list of melds (combinations of cards) that the player has laid down, visible to all players.\"}, \"facedown_cards\": {\"hand\": \"A list of cards currently in the player's hand, not visible to other players.\", \"recent_discard_draw\": \"A list of cards recently drawn from the discard pile by the player, used to track draw actions.\"}}, {\"facedown_cards\": {\"hand_size\": \"The number of cards in the player's hand, without showing the actual cards.\", \"recent_discard_draw_size\": \"The size of the player's recent discard draw list.\"}}], \"legal_actions\": [{\"action\": \"The name of the action that the current player can legally perform.\", \"args\": \"The arguments or parameters associated with the action the player can take.\", \"id\": \"A unique identifier for the action, which can be used to select or reference it in the game.\"}]}",
    "policy_list": [
        "**Prioritize Building Melds**\nFocus on arranging cards in the hand into matched sets of either three or four of a kind, or sequences of three or more cards of the same suit. Discard cards that do not contribute towards completing a meld.",
        "**Strategic Discarding**\nChoose to discard cards that are least likely to be useful to other players based on previously observed discards and draws. Avoid discarding cards that could easily be used to complete an opponent's meld.",
        "**Draw from Discard Pile Judiciously**\nOnly draw from the discard pile when the top two cards can be directly used to form a meld or significantly improve the hand. Otherwise, prefer drawing from the stock pile to maintain unpredictability.",
        "**Reserve Key Cards**\nKeep hold of high-value cards like aces and face cards only if they are part of an ongoing strategy to complete a meld or if they are necessary to win the game soon. Otherwise, discard them to minimize penalty points."
    ],
    "code": [
        "\ndef score(state: dict, action: dict) -> float:\n    def rank_value(rank):\n        \"\"\"Assign numerical values to card ranks for easier comparison.\"\"\"\n        values = {'A': 1, '2': 2, '3': 3, '4': 4, '5': 5, '6': 6, '7': 7,\n                  '8': 8, '9': 9, '10': 10, 'J': 11, 'Q': 12, 'K': 13}\n        return values[rank]\n\n    def evaluate_meld_potential(hand):\n        \"\"\"Estimate the potential of forming melds with the current hand.\"\"\"\n        rank_count = {}\n        suit_sequences = {}\n\n        for card in hand:\n            rank_count[card['rank']] = rank_count.get(card['rank'], 0) + 1\n            suit_sequences.setdefault(card['suit'], []).append(rank_value(card['rank']))\n\n        # Count potential melds\n        meld_score = 0\n        # Check for pairs or trips that might become melds of a rank\n        for count in rank_count.values():\n            if count >= 2:\n                meld_score += count\n\n        # Check for sequences in suits\n        for seq in suit_sequences.values():\n            seq.sort()\n            current_seq_length = 1\n            for i in range(1, len(seq)):\n                if seq[i] == seq[i-1] + 1:\n                    current_seq_length += 1\n                else:\n                    current_seq_length = 1\n                \n                if current_seq_length >= 3:\n                    meld_score += current_seq_length\n\n        return meld_score\n\n    def position_in_game(state):\n        \"\"\"Consider the game stage to weigh early/later actions differently.\"\"\"\n        stock_size = state['common']['facedown_cards']['stock_size']\n        num_players = state['common']['num_players']\n        avg_hand_size = stock_size / num_players\n        return avg_hand_size\n\n    # Start evaluation\n    current_hand = state['players'][state['common']['current_player']]['facedown_cards']['hand']\n    current_meld_potential = evaluate_meld_potential(current_hand)\n\n    # Evaluate action impact on meld potential\n    if action['action'] == 'draw':\n        if action['args']['source'] == 'discard_pile':\n            if len(state['common']['faceup_cards']['discard_pile']) >= 2:\n                discard_top = state['common']['faceup_cards']['discard_pile'][-1]\n                discard_next = state['common']['faceup_cards']['discard_pile'][-2]\n                hypothetical_hand = current_hand + [discard_top, discard_next]\n                new_meld_potential = evaluate_meld_potential(hypothetical_hand)\n            else:\n                new_meld_potential = current_meld_potential\n        else:  # Drawing from stock, uncertainty involved\n            new_meld_potential = current_meld_potential  # Assume no immediate benefit\n    else:\n        new_meld_potential = current_meld_potential\n\n    # Calculate a dynamic reward between 0 and 1\n    meld_potential_gain = max(0, (new_meld_potential - current_meld_potential))\n    game_stage = position_in_game(state)\n    result_score = 0.5 + 0.05 * meld_potential_gain + 0.2 * (30 - game_stage) / 30\n\n    return min(1.0, max(0.0, result_score))\n\n",
        "\ndef score(state: dict, action: dict) -> float:\n    rank_values = {'A': 1, '2': 2, '3': 3, '4': 4, '5': 5, '6': 6, '7': 7,\n                   '8': 8, '9': 9, '10': 10, 'J': 11, 'Q': 12, 'K': 13}\n    current_player_state = state[\"players\"][state[\"common\"][\"current_player\"]]\n    \n    hand = current_player_state[\"facedown_cards\"][\"hand\"]\n    \n    # Calculate hand score\n    hand_value_score = sum(rank_values[card['rank']] for card in hand)\n    \n    # Evaluate meldability\n    numbers = {str(i) for i in range(1, 11)}.union({'J', 'Q', 'K', 'A'})\n    rank_count = {n: 0 for n in numbers}\n    suit_sequences = {'clubs': [], 'diamonds': [], 'hearts': [], 'spades': []}\n    \n    for card in hand:\n        rank_count[card['rank']] += 1\n        suit_sequences[card['suit']].append(card['rank'])\n    \n    triple_or_quadruples = sum(1 for count in rank_count.values() if count >= 3)\n    potential_sequences = sum(len(sequence) >= 3 for sequence in suit_sequences.values())\n    meldability_score = triple_or_quadruples + potential_sequences\n\n    # Evaluate action value\n    action_score = 0\n    if action['action'] == 'draw' and action['args']['source'] == 'stock':\n        action_score = 0.4\n    if action['action'] == 'draw' and action['args']['source'] == 'discard_pile':\n        action_score = 0.6\n    \n    # Normalize hand value\n    normalizer = max(1, len(hand))\n    normalized_hand_value_score = 1 - (hand_value_score / (normalizer * 13))\n    \n    # Aggregate scores\n    result_score = (0.6 * normalized_hand_value_score +\n                    0.3 * (meldability_score / 10) +\n                    0.1 * action_score)\n    \n    result_score = min(max(result_score, 0), 1)  # Ensure it's between 0 and 1\n    return result_score\n",
        "\ndef score(state: dict, action: dict) -> float:\n    # Extract important variables from state\n    current_player_index = state[\"common\"][\"current_player\"]\n    current_player = state[\"players\"][current_player_index]\n    hand = current_player[\"facedown_cards\"][\"hand\"]\n    discard_pile = state[\"common\"][\"faceup_cards\"][\"discard_pile\"]\n\n    # Evaluate action\n    action_id = action[\"id\"]\n    action_type = action[\"action\"]\n    result_score = 0.0\n    \n    # Define a simple helper function to determine hand strength\n    def hand_strength(hand):\n        rank_counter = {}\n        suit_counter = {}\n        for card in hand:\n            rank = card[\"rank\"]\n            suit = card[\"suit\"]\n            rank_counter[rank] = rank_counter.get(rank, 0) + 1\n            suit_counter[suit] = suit_counter.get(suit, 0) + 1\n\n        # Evaluate potential melds in the hand\n        potential_melds = 0\n        for count in rank_counter.values():\n            if count >= 3:\n                potential_melds += 1\n        for count in suit_counter.values():\n            if count >= 3:\n                potential_melds += 1\n\n        return potential_melds / max(len(hand), 1)\n\n    # Evaluate the action: draw_from_discard\n    if action_type == \"draw_from_discard\":\n        # Determine if top cards of the discard pile are useful\n        if len(discard_pile) == 0:\n            return 0.0\n        \n        top_discard_card = discard_pile[-1]\n        second_discard_card = discard_pile[-2] if len(discard_pile) > 1 else None\n        \n        # Check if these can help form a set or sequence with current hand\n        discard_ranks = {top_discard_card[\"rank\"], second_discard_card[\"rank\"]} if second_discard_card else {top_discard_card[\"rank\"]}\n        \n        potential_hand = hand + [top_discard_card] + ([second_discard_card] if second_discard_card else [])\n        \n        if any(potential_hand.count({\"rank\": rank, \"suit\": card['suit']}) >= 2 for rank in discard_ranks for card in hand):\n            result_score = 0.8 * hand_strength(potential_hand)\n        else:\n            result_score = 0.5 * hand_strength(hand)\n    \n    # Evaluate the action: draw_from_stock\n    elif action_type == \"draw_from_stock\":\n        # Drawing from the stock does not guarantee improvement but maintains unpredictability\n        result_score = 0.6 * hand_strength(hand)\n    \n    return min(max(result_score, 0.0), 1.0)  # Ensure the score is between 0 and 1\n",
        "\ndef score(state: dict, action: dict) -> float:\n    num_players = state['common']['num_players']\n    current_player = state['common']['current_player']\n    has_drawn_cards_this_turn = state['common']['has_drawn_cards_this_turn']\n    is_over = state['common']['is_over']\n    discard_pile = state['common']['faceup_cards']['discard_pile']\n    stock_size = state['common']['facedown_cards']['stock_size']\n    \n    player_hand = state['players'][current_player]['facedown_cards']['hand']\n    player_score = state['players'][current_player]['public']['score']\n    player_melds = state['players'][current_player]['faceup_cards']['melds']\n    \n    action_type = action['action']\n    action_id = action['id']\n    action_args = action['args']\n    \n    result_score = 0.5\n    \n    def card_value(card):\n        if card['rank'] in ['K', 'Q', 'J']:\n            return 10\n        if card['rank'] == 'A':\n            return 11\n        return int(card['rank'])\n    \n    def calculate_hand_value(hand):\n        return sum(card_value(card) for card in hand)\n    \n    # Naive potential melds checker\n    def potential_melds(hand):\n        ranks = [card['rank'] for card in hand]\n        suits = [card['suit'] for card in hand]\n        rank_melds = any(ranks.count(rank) >= 3 for rank in ranks)\n        suit_melds = any(suits.count(suit) >= 3 for suit in suits)\n        return rank_melds or suit_melds\n\n    if is_over:\n        return 1.0 if state['common']['winner'] == current_player else 0.0\n\n    if action_type == \"draw\" and not has_drawn_cards_this_turn:\n        if action_args['source'] == \"stock\" and stock_size > 0:\n            result_score += 0.1\n        elif action_args['source'] == \"discard_pile\" and discard_pile:\n            result_score += 0.2\n\n    hand_value = calculate_hand_value(player_hand)\n    if hand_value > 30:\n        result_score -= 0.2\n\n    if player_melds or potential_melds(player_hand):\n        result_score += 0.2\n\n    result_score = max(0, min(1, result_score))\n    \n    return result_score\n"
    ]
}