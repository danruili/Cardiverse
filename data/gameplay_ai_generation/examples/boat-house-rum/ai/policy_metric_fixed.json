{
    "game_description": "### Rank of Cards\n\nK (high), Q, J, 10, 9, 8, 7, 6, 5, 4, 3, 2, A. (In many forms of Rummy, the ace may rank either high or low).\n\n### The Deal\n\nDealer gives one card at a time face down, beginning with the player on the left. When two people play, each person gets 10 cards. When three or four people play, each receives seven cards; when five or six play, each receives six cards. The remaining cards are placed face down on the table, forming the stock.\n\nThe top card of the stock is turned face up and becomes the upcard. It is placed next to the stock to start the discard pile.\n\nWhen two people play, the winner of each hand deals the next. When more than two play, the deal passes to next the player on the left.\n\n### Object of the Game\n\nEach player tries to form matched sets consisting of groups of three or four of a kind, or sequences of three or more cards of the same suit.\n\nAn ace counts either high or low in a sequence, and sequences may go round the corner as in K, A, 2, or A, K, Q.\n\n### The Play\n\nBeginning with the player to the left of the dealer, each player in turn may draw two cards from the stock or, before drawing those cards, two cards from the top of the discard pile. Then the player discards only one card. Play does not end until a player can lay down their entire hand at once.\n\nThe player may also lie down on the table, face up, any meld (matched set). If the player does not wish to lay down a meld, they discard one card, face up, onto the discard pile. If the player has drawn from the discard pile, they may not discard the same card on that turn.\n\n### Laying Off\n\nA player may add one or more from their hand to any matched set already shown on the table. Thus, if threes are showing, they may add the fourth three; if 10, 9, 8 are showing, he may add J, or Q, J, 7, or 7, 6.\n\n### Going Out\n\nWhen a player gets rid of all of their cards, they win the game.\n\nIf the last card of the stock has been drawn and no player has gone out, the next player in turn may either take the top of the discard pile, or may turn the discard pile over to form a new stock (without shuffling it) and draw the top card. Play then proceeds as before.\n\n### How to Keep Score\n\nA player pays only for cards in their hand, which does not form matched sets. A player pays the pip value of all unmatched cards, with the ace counting as 11 points\n\nA player goes \"rummy\" when they get rid of all cards in their hand at once, without previously having put down or laid off any cards. In this event, every other player pays double - twice what their opponents would otherwise owe.",
    "input_description": "Example: \n{\"common\": {\"num_players\": 3, \"current_player\": 0, \"winner\": null, \"has_drawn_cards_this_turn\": false, \"is_over\": false, \"faceup_cards\": {\"discard_pile\": [{\"rank\": \"4\", \"suit\": \"clubs\"}, {\"rank\": \"5\", \"suit\": \"hearts\"}]}, \"facedown_cards\": {\"stock_size\": 26}}, \"players\": [{\"public\": {\"score\": 0, \"current_player\": true}, \"faceup_cards\": {\"melds\": []}, \"facedown_cards\": {\"hand\": [{\"rank\": \"Q\", \"suit\": \"clubs\"}, {\"rank\": \"Q\", \"suit\": \"diamonds\"}, {\"rank\": \"5\", \"suit\": \"diamonds\"}, {\"rank\": \"J\", \"suit\": \"hearts\"}, {\"rank\": \"2\", \"suit\": \"hearts\"}, {\"rank\": \"6\", \"suit\": \"clubs\"}, {\"rank\": \"2\", \"suit\": \"spades\"}, {\"rank\": \"5\", \"suit\": \"spades\"}], \"recent_discard_draw\": []}}, {\"public\": {\"score\": 0}, \"faceup_cards\": {\"melds\": []}, \"facedown_cards\": {\"hand_size\": 8, \"recent_discard_draw_size\": 0}}, {\"public\": {\"score\": 0}, \"faceup_cards\": {\"melds\": []}, \"facedown_cards\": {\"hand_size\": 8, \"recent_discard_draw_size\": 0}}], \"legal_actions\": [{\"action\": \"draw\", \"args\": {\"source\": \"stock\"}, \"id\": 0}, {\"action\": \"draw\", \"args\": {\"source\": \"discard_pile\"}, \"id\": 1}]}\n\nExplanation: \n{\"common\": {\"num_players\": \"The total number of players participating in the game.\", \"current_player\": \"The index of the player whose turn it is currently.\", \"winner\": \"The index of the player who has won the game, or null if there is no winner yet.\", \"has_drawn_cards_this_turn\": \"A boolean indicating whether the current player has drawn cards during their current turn.\", \"is_over\": \"A boolean indicating if the game has ended.\", \"faceup_cards\": {\"discard_pile\": \"A list of cards that are currently in the discard pile, visible to all players.\"}, \"facedown_cards\": {\"stock_size\": \"The number of cards remaining in the stock pile, which is not visible to players.\"}}, \"players\": [{\"public\": {\"score\": \"The player's score, which is publicly visible.\", \"current_player\": \"A boolean indicating if this player is the current player.\"}, \"faceup_cards\": {\"melds\": \"A list of melds (combinations of cards) that the player has laid down, visible to all players.\"}, \"facedown_cards\": {\"hand\": \"A list of cards currently in the player's hand, not visible to other players.\", \"recent_discard_draw\": \"A list of cards recently drawn from the discard pile by the player, used to track draw actions.\"}}, {\"facedown_cards\": {\"hand_size\": \"The number of cards in the player's hand, without showing the actual cards.\", \"recent_discard_draw_size\": \"The size of the player's recent discard draw list.\"}}], \"legal_actions\": [{\"action\": \"The name of the action that the current player can legally perform.\", \"args\": \"The arguments or parameters associated with the action the player can take.\", \"id\": \"A unique identifier for the action, which can be used to select or reference it in the game.\"}]}",
    "policy_list": [
        "**PotentialMeldCreationValue**\nA metric that assesses the potential of forming new melds after drawing two cards, either from the stock pile or discard pile. It evaluates the likely improvement in the hand's structure, considering both the draw options and the current meld opportunities.",
        "**UnmatchedCardPenalty**\nA metric that evaluates the penalty incurred from holding high-value unmatched cards. This metric helps in deciding the priority of discarding high-value cards from the hand to lower potential score penalties.",
        "**MeldCompletionLikelihood**\nA metric that calculates the likelihood of completing a potential meld based on the known cards in the discard pile and the cards currently forming partial melds in hand. It helps in determining the value of laying off or holding cards for future turns.",
        "**OpponentInterferenceRisk**\nA metric that estimates the risk of laying down or discarding a card that might benefit opponents. This assessment is based on the current visible card distributions (discard pile and known melds), and helps avoid actions that could strengthen opponents\u2019 hands."
    ],
    "code": [
        "\ndef score(state: dict, action: dict) -> float:\n    import random\n\n    def rank_value(rank):\n        value_dict = {'A': 1, '2': 2, '3': 3, '4': 4, '5': 5, '6': 6, \n                      '7': 7, '8': 8, '9': 9, '10': 10, 'J': 11, 'Q': 12, 'K': 13}\n        return value_dict.get(rank, 0)\n\n    current_player_hand = state['players'][state['common']['current_player']]['facedown_cards']['hand']\n\n    all_ranks = ['A', '2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K']\n    all_suits = ['hearts', 'diamonds', 'clubs', 'spades']\n    \n    # Correct handling for when 'source' does not exist in action['args']\n    source = action.get('args', {}).get('source', 'stock')\n    \n    if source == \"stock\":\n        fictive_draw = [{'rank': random.choice(all_ranks), 'suit': random.choice(all_suits)} for _ in range(2)]\n    elif source == \"discard_pile\":\n        discard_pile = state['common']['faceup_cards']['discard_pile']\n        fictive_draw = discard_pile[-2:] if len(discard_pile) >= 2 else discard_pile[-1:]\n    else:\n        raise ValueError(\"Invalid draw source specified\")\n\n    def potential_meld_impact(hand, drawn_cards):\n        combined_hand = hand + drawn_cards\n        potential_melds = 0\n        \n        rank_counts = {}\n        for card in combined_hand:\n            rank = card['rank']\n            if rank in rank_counts:\n                rank_counts[rank] += 1\n            else:\n                rank_counts[rank] = 1\n\n        for count in rank_counts.values():\n            if count >= 3:\n                potential_melds += 1\n\n        suits = {'hearts': [], 'diamonds': [], 'clubs': [], 'spades': []}\n        for card in combined_hand:\n            suits[card['suit']].append(rank_value(card['rank']))\n        \n        for suit, ranks in suits.items():\n            ranks.sort()\n            consecutive = 0\n            for i in range(len(ranks) - 1):\n                if ranks[i] == ranks[i + 1] - 1:\n                    consecutive += 1\n                    if consecutive >= 2:\n                        potential_melds += 1\n                else:\n                    consecutive = 0\n\n        return potential_melds\n\n    impact = potential_meld_impact(current_player_hand, fictive_draw)\n\n    max_possible_melds = 4\n    result_score = min(impact / max_possible_melds, 1.0)\n    \n    return result_score\n",
        "\ndef score(state: dict, action: dict) -> float:\n    def card_value(rank: str) -> int:\n        \"\"\"Helper function to get the pip value of the card.\"\"\"\n        values = {'A': 11, '2': 2, '3': 3, '4': 4, '5': 5, '6': 6, '7': 7, '8': 8, '9': 9, '10': 10, 'J': 10, 'Q': 10, 'K': 10}\n        return values[rank]\n\n    def calculate_unmatched_penalty(hand: list) -> int:\n        \"\"\"Calculate the penalty from holding unmatched cards based on their value.\"\"\"\n        penalty = 0\n        for card in hand:\n            penalty += card_value(card['rank'])\n        return penalty\n    \n    # Extract current player's hand\n    current_player_index = state['common']['current_player']\n    current_hand = state['players'][current_player_index]['facedown_cards']['hand']\n    \n    # Calculate penalty for current hand\n    unmatched_penalty = calculate_unmatched_penalty(current_hand)\n    \n    # Estimate how the action affects the penalty\n    action_type = action['action']\n    if action_type == \"draw\":\n        # Assuming drawing from stock doesn't change penalty count immediately\n        pass\n    elif action_type == \"discard\":\n        # Simulate the discarding action to adjust the penalty\n        card_index = action['args']['card_idx']\n        card_to_discard = current_hand[card_index]\n        unmatched_penalty -= card_value(card_to_discard['rank'])\n\n    # Normalize the penalty to a reward score, higher penalty means lower score\n    max_hand_penalty = 11 * len(current_hand)  # Assuming full penalty of Ace for each card\n    result_score = 1 - (unmatched_penalty / max_hand_penalty)\n    \n    # Ensure the result is between 0 and 1\n    result_score = max(0, min(result_score, 1))\n    \n    return result_score\n",
        "\ndef score(state: dict, action: dict) -> float:\n    # Helper to map card ranks to numeric values\n    def card_value(card):\n        ranks = {'2': 2, '3': 3, '4': 4, '5': 5,\n                 '6': 6, '7': 7, '8': 8, '9': 9,\n                 '10': 10, 'J': 11, 'Q': 12, 'K': 13, 'A': 1}\n        return ranks.get(card['rank'], 0)\n    \n    current_player = state[\"common\"][\"current_player\"]\n    player_hand = state[\"players\"][current_player][\"facedown_cards\"][\"hand\"]\n    discard_pile = state[\"common\"][\"faceup_cards\"][\"discard_pile\"]\n\n    # Evaluating meld likelihood\n    potential_meld_likelihood = 0.0\n    hand_ranks = [card['rank'] for card in player_hand]\n    discard_ranks = [card['rank'] for card in discard_pile]\n\n    total_potential_melds = 0\n    for rank in set(hand_ranks):\n        count_in_hand = hand_ranks.count(rank)\n        count_in_discard = discard_ranks.count(rank)\n        if count_in_hand + count_in_discard >= 3:\n            total_potential_melds += (count_in_hand + count_in_discard - 2) / 2\n\n    suits = ['clubs', 'diamonds', 'hearts', 'spades']\n    for suit in suits:\n        suit_hand_values = sorted(card_value(card) for card in player_hand if card['suit'] == suit)\n        suit_discard_values = sorted(card_value(card) for card in discard_pile if card['suit'] == suit)\n        combined_suit_values = sorted(set(suit_hand_values + suit_discard_values))\n        seq_count = 1\n        max_seq_count = 0\n        for i in range(1, len(combined_suit_values)):\n            if combined_suit_values[i] == combined_suit_values[i-1] + 1:\n                seq_count += 1\n            else:\n                seq_count = 1\n            if seq_count >= 3:\n                max_seq_count = max(max_seq_count, seq_count)\n        total_potential_melds += (max_seq_count - 2) / 3\n\n    potential_meld_likelihood = min(total_potential_melds / 3, 1)\n\n    # Action desirability\n    action_score = 0.5\n    if action[\"action\"] == \"draw\" and action[\"args\"][\"source\"] == \"discard_pile\":\n        discarded_card = discard_pile[-1]\n        if (discarded_card[\"rank\"] in [card[\"rank\"] for card in player_hand] or\n            discarded_card[\"suit\"] in [card[\"suit\"] for card in player_hand]):\n            action_score = 0.7\n\n    result_score = 0.5 * potential_meld_likelihood + 0.5 * action_score\n    return result_score\n",
        "\ndef score(state: dict, action: dict) -> float:\n    def get_card_value(card):\n        # Assign values based on rank and suit - simplification for OpponentInterferenceRisk\n        rank_values = {\n            'A': 1, '2': 2, '3': 3, '4': 4, '5': 5, '6': 6,\n            '7': 7, '8': 8, '9': 9, '10': 10, 'J': 11, 'Q': 12, 'K': 13\n        }\n        return rank_values[card['rank']]\n\n    def interference_risk(action, discard_pile, player_hand):\n        # Calculate risk based on potential benefit to opponents by discarding the selected card\n        risk_score = 0\n        if action['action'] == 'discard':\n            card_idx = action['args']['card_idx']\n            chosen_card = player_hand[card_idx]\n            if any(chosen_card['rank'] == up_card['rank'] or chosen_card['suit'] == up_card['suit'] for up_card in discard_pile):\n                risk_score += 1\n            return risk_score / len(player_hand)\n        # If the action is not a discard, risk is not based specifically on interference potential\n        return 0\n\n    # Extract necessary information from the state\n    common_state = state['common']\n    players = state['players']\n    current_player = players[common_state['current_player']]\n    discard_pile = common_state['faceup_cards']['discard_pile']\n    player_hand = current_player['facedown_cards']['hand']\n    \n    # Assign some base values to current progress towards winning based on melds and hand value\n    meld_score = sum(len(meld) for meld in current_player['faceup_cards']['melds'])\n    max_possible_meld_score = 10 if common_state['num_players'] == 2 else 7\n    meld_proportion = meld_score / max_possible_meld_score\n\n    hand_value = sum(get_card_value(card) for card in player_hand)\n    max_hand_value = 100\n    hand_value_proportion = 1 - (hand_value / max_hand_value)\n\n    # Calculate interference risk for a given action\n    risk_interference = interference_risk(action, discard_pile, player_hand)\n\n    # Combine various metrics to output a single score between 0 and 1\n    score = (0.5 * meld_proportion) + (0.3 * hand_value_proportion) - (0.2 * risk_interference)\n    result_score = max(0, min(score, 1))  # Ensure result_score stays between 0 and 1\n\n    return result_score\n"
    ]
}