{
    "game_description": "### Rank of Cards\n\nK (high), Q, J, 10, 9, 8, 7, 6, 5, 4, 3, 2, A. (In many forms of Rummy, the ace may rank either high or low).\n\n### The Deal\n\nDealer gives one card at a time face down, beginning with the player on the left. When two people play, each person gets 10 cards. When three or four people play, each receives seven cards; when five or six play, each receives six cards. The remaining cards are placed face down on the table, forming the stock.\n\nThe top card of the stock is turned face up and becomes the upcard. It is placed next to the stock to start the discard pile.\n\nWhen two people play, the winner of each hand deals the next. When more than two play, the deal passes to next the player on the left.\n\n### Object of the Game\n\nEach player tries to form matched sets consisting of groups of three or four of a kind, or sequences of three or more cards of the same suit.\n\nAn ace counts either high or low in a sequence, and sequences may go round the corner as in K, A, 2, or A, K, Q.\n\n### The Play\n\nBeginning with the player to the left of the dealer, each player in turn may draw two cards from the stock or, before drawing those cards, two cards from the top of the discard pile. Then the player discards only one card. Play does not end until a player can lay down their entire hand at once.\n\nThe player may also lie down on the table, face up, any meld (matched set). If the player does not wish to lay down a meld, they discard one card, face up, onto the discard pile. If the player has drawn from the discard pile, they may not discard the same card on that turn.\n\n### Laying Off\n\nA player may add one or more from their hand to any matched set already shown on the table. Thus, if threes are showing, they may add the fourth three; if 10, 9, 8 are showing, he may add J, or Q, J, 7, or 7, 6.\n\n### Going Out\n\nWhen a player gets rid of all of their cards, they win the game.\n\nIf the last card of the stock has been drawn and no player has gone out, the next player in turn may either take the top of the discard pile, or may turn the discard pile over to form a new stock (without shuffling it) and draw the top card. Play then proceeds as before.\n\n### How to Keep Score\n\nA player pays only for cards in their hand, which does not form matched sets. A player pays the pip value of all unmatched cards, with the ace counting as 11 points\n\nA player goes \"rummy\" when they get rid of all cards in their hand at once, without previously having put down or laid off any cards. In this event, every other player pays double - twice what their opponents would otherwise owe.",
    "input_description": "Example: \n{\"common\": {\"num_players\": 3, \"current_player\": 0, \"winner\": null, \"has_drawn_cards_this_turn\": false, \"is_over\": false, \"faceup_cards\": {\"discard_pile\": [{\"rank\": \"4\", \"suit\": \"clubs\"}, {\"rank\": \"5\", \"suit\": \"hearts\"}]}, \"facedown_cards\": {\"stock_size\": 26}}, \"players\": [{\"public\": {\"score\": 0, \"current_player\": true}, \"faceup_cards\": {\"melds\": []}, \"facedown_cards\": {\"hand\": [{\"rank\": \"Q\", \"suit\": \"clubs\"}, {\"rank\": \"Q\", \"suit\": \"diamonds\"}, {\"rank\": \"5\", \"suit\": \"diamonds\"}, {\"rank\": \"J\", \"suit\": \"hearts\"}, {\"rank\": \"2\", \"suit\": \"hearts\"}, {\"rank\": \"6\", \"suit\": \"clubs\"}, {\"rank\": \"2\", \"suit\": \"spades\"}, {\"rank\": \"5\", \"suit\": \"spades\"}], \"recent_discard_draw\": []}}, {\"public\": {\"score\": 0}, \"faceup_cards\": {\"melds\": []}, \"facedown_cards\": {\"hand_size\": 8, \"recent_discard_draw_size\": 0}}, {\"public\": {\"score\": 0}, \"faceup_cards\": {\"melds\": []}, \"facedown_cards\": {\"hand_size\": 8, \"recent_discard_draw_size\": 0}}], \"legal_actions\": [{\"action\": \"draw\", \"args\": {\"source\": \"stock\"}, \"id\": 0}, {\"action\": \"draw\", \"args\": {\"source\": \"discard_pile\"}, \"id\": 1}]}\n\nExplanation: \n{\"common\": {\"num_players\": \"The total number of players participating in the game.\", \"current_player\": \"The index of the player whose turn it is currently.\", \"winner\": \"The index of the player who has won the game, or null if there is no winner yet.\", \"has_drawn_cards_this_turn\": \"A boolean indicating whether the current player has drawn cards during their current turn.\", \"is_over\": \"A boolean indicating if the game has ended.\", \"faceup_cards\": {\"discard_pile\": \"A list of cards that are currently in the discard pile, visible to all players.\"}, \"facedown_cards\": {\"stock_size\": \"The number of cards remaining in the stock pile, which is not visible to players.\"}}, \"players\": [{\"public\": {\"score\": \"The player's score, which is publicly visible.\", \"current_player\": \"A boolean indicating if this player is the current player.\"}, \"faceup_cards\": {\"melds\": \"A list of melds (combinations of cards) that the player has laid down, visible to all players.\"}, \"facedown_cards\": {\"hand\": \"A list of cards currently in the player's hand, not visible to other players.\", \"recent_discard_draw\": \"A list of cards recently drawn from the discard pile by the player, used to track draw actions.\"}}, {\"facedown_cards\": {\"hand_size\": \"The number of cards in the player's hand, without showing the actual cards.\", \"recent_discard_draw_size\": \"The size of the player's recent discard draw list.\"}}], \"legal_actions\": [{\"action\": \"The name of the action that the current player can legally perform.\", \"args\": \"The arguments or parameters associated with the action the player can take.\", \"id\": \"A unique identifier for the action, which can be used to select or reference it in the game.\"}]}",
    "policy_list": [
        "**Refined Meld Building Strategy**\nTo refine the strategy for building melds, the AI player should incorporate the following steps: prioritize drawing from the source that maximizes 'PotentialMeldCreationValue.' When choosing cards to discard, evaluate based on 'UnmatchedCardPenalty,' preferably discarding high-penalty cards unless they significantly contribute to potential melds. Use 'MeldCompletionLikelihood' to assess laying off opportunities. Lastly, factor in 'OpponentInterferenceRisk' to prevent assisting opponents with your discards. These criteria ensure strategic decision-making based on the game state, maximizing winning potential and minimizing penalties.",
        "**Refined Strategic Discarding**\nThe 'Strategic Discarding' strategy is refined to systematically choose cards to discard by evaluating several game state metrics. \n\n1. **OpponentInterferenceRisk**: Use this metric to assess the likelihood that a discarded card will complete or assist in completing an opponent\u2019s meld. Cards with high interference risk should be kept unless they carry a significant 'UnmatchedCardPenalty'. The risk is calculated based on observed opponent patterns and known discards. \n\n2. **UnmatchedCardPenalty**: Assess the penalty from holding cards that are unlikely to complete a meld soon and carry a high pip value. Prioritize discarding these cards unless they possess a high 'OpponentInterferenceRisk'. \n\nWith these conditions, the AI player better disrupts opponents\u2019 strategies and reduces penalty risks, improving the chance of maintaining a competitive edge.",
        "**Draw from Discard Pile Judiciously**\nOnly draw from the discard pile when the top two cards directly form a meld or increase the MeldCompletionLikelihood by 50% or more, based on the PotentialMeldCreationValue. Additionally, evaluate the UnmatchedCardPenalty to ensure that drawing cards does not excessively increase the risk of holding high-value unmatched cards. This strategy will minimize revealing strategic intent to opponents while optimizing hand composition.",
        "**Refined Strategic Card Holding**\nThis refined strategy involves holding onto high-value cards like aces and face cards only when 'PotentialMeldCreationValue' is high enough to suggest that these cards are integral to completing a meld in the immediate future. A 'MeldCompletionLikelihood' above a certain threshold should be a trigger to keep these cards. The strategy should pivot to discarding high-value unmatched cards if both these metrics indicate low likelihood of imminent meld creation, leveraging 'UnmatchedCardPenalty' to continuously reduce point risk. Additionally, introduce 'OpponentInterferenceRisk' as a counterbalance; if discarding a card increases opponents' chances significantly, reconsider discarding unless absolutely necessary for penalty mitigation. Critical moments are dynamically defined through these metrics: if meld creation seems feasible within one or two upcoming turns with high-value cards or if another player seems poised to win imminently, the decision on holding or discarding must adjust accordingly."
    ],
    "code": [
        "\ndef score(state: dict, action: str) -> float:\n    # Helper function to calculate the potential meld creation value\n    def calculate_potential_meld_creation_value(hand, card):\n        value = 0\n        # Check for potential sets (three or four of a kind)\n        rank_count = sum(1 for c in hand if c['rank'] == card['rank'])\n        if rank_count == 2: # possibility to make a set of three\n            value += 0.3\n        if rank_count == 3: # possibility to make a set of four\n            value += 0.5\n        \n        # Check for potential sequences\n        card_ranks = {'A': 1, '2': 2, '3': 3, '4': 4, '5': 5, '6': 6,\n                      '7': 7, '8': 8, '9': 9, '10': 10, 'J': 11, 'Q': 12, 'K': 13}\n        hand_ranks = [card_ranks[c['rank']] for c in hand if c['suit'] == card['suit']]\n        hand_ranks.append(card_ranks[card['rank']])\n        hand_ranks.sort()\n        \n        # Look for consecutive cards\n        for i in range(len(hand_ranks) - 2):\n            if hand_ranks[i+1] == hand_ranks[i] + 1 and hand_ranks[i+2] == hand_ranks[i] + 2:\n                value += 0.4\n                \n        return value\n\n    # Helper function to calculate unmatched card penalty\n    def calculate_unmatched_card_penalty(hand):\n        penalty = 0\n        for card in hand:\n            penalty += {'A': 11, 'K': 10, 'Q': 10, 'J': 10,\n                        '10': 10, '9': 9, '8': 8, '7': 7,\n                        '6': 6, '5': 5, '4': 4, '3': 3, '2': 2}[card['rank']]\n        return penalty\n\n    # Extract relevant information\n    current_player_index = state['common']['current_player']\n    current_player = state['players'][current_player_index]\n    hand = current_player['facedown_cards']['hand']\n    discard_pile = state['common']['faceup_cards']['discard_pile']\n\n    # Initialize the result score\n    result_score = 0.0\n\n    # Calculate potential meld creation value of the action\n    if action == \"draw\":\n        draw_source = state['legal_actions'][0]['args']['source']  # assuming we're provided with actions arguments\n        \n        # Check both stock and discard pile for card drawing\n        if draw_source == \"stock\":\n            # Assuming uncertainty based draw, hence less score boost\n            result_score += 0.1  # a relatively small optimistic boost for drawing\n        elif draw_source == \"discard_pile\":\n            if discard_pile:\n                top_discard_card = discard_pile[-1]\n                result_score += calculate_potential_meld_creation_value(hand, top_discard_card)\n            else:\n                result_score += 0.05  # minor score addition when discard pile is empty\n\n    # Evaluating penalty for unmatched cards\n    unmatched_penalty = calculate_unmatched_card_penalty(hand)\n    result_score -= unmatched_penalty * 0.01  # reduce score proportionally to the penalty\n\n    # Make sure that the final score is between 0 and 1\n    result_score = max(0, min(1, result_score))\n\n    return result_score\n",
        "\ndef score(state: dict, action: dict) -> float:\n    def calculate_opponent_interference_risk(card, opponent_melds):\n        # Calculate the risk of a card aiding opponents based on visible melds\n        for meld in opponent_melds:\n            if (card[\"rank\"] in meld) or (card[\"suit\"] == meld.get(\"suit\", \"\")):\n                return 0.8  # High risk by default if it aligns with any meld\n        return 0.1  # Low risk if not aligned with any visible meld\n\n    def calculate_unmatched_card_penalty(card):\n        card_values = {'A': 11, 'K': 10, 'Q': 10, 'J': 10, '10': 10,\n                       '9': 9, '8': 8, '7': 7, '6': 6, '5': 5,\n                       '4': 4, '3': 3, '2': 2}\n        return card_values[card['rank']]\n\n    def evaluate_hand(hand, opponent_melds):\n        total_penalty = 0\n        interference_penalty = 0\n        for card in hand:\n            unmatched_penalty = calculate_unmatched_card_penalty(card)\n            interference_risk = calculate_opponent_interference_risk(card, opponent_melds)\n            # Weigh unmatched penalty against interference risk\n            if interference_risk > 0.6:\n                total_penalty += interference_risk * 0.5  # less emphasis on high interference cards\n            else:\n                total_penalty += unmatched_penalty * 0.5  # more emphasis on high penalty cards\n            interference_penalty += interference_risk\n        \n        # Normalize penalties into a reward score\n        normalized_penalty = min(1, total_penalty / max(1, len(hand) * 10))\n        normalized_interference = min(1, interference_penalty / max(1, len(hand)))\n\n        # Higher penalties and interference risks = lower score\n        return 1 - (0.5 * normalized_penalty + 0.5 * normalized_interference)\n\n    # Evaluate the current player's decision impact\n    def evaluate_game_state(player_state, common_state):\n        opponent_melds = []\n        for player in state['players']:\n            if player is not player_state:\n                opponent_melds.extend(player['faceup_cards']['melds'])\n\n        # Evaluate only the current player's actions\n        player_hand = player_state['facedown_cards']['hand']\n        return evaluate_hand(player_hand, opponent_melds)\n\n    # Identify the current player's state\n    current_player_state = state['players'][state['common']['current_player']]\n    game_reward = evaluate_game_state(current_player_state, state['common'])\n\n    # Adjust the score based on the proposed action type\n    # More sophisticated logic can go here based on action details\n    action_type = action['action']\n    if action_type == \"draw\":\n        if action['args']['source'] == \"stock\":\n            game_reward *= 1.0  # Draw from stock is neutral\n        elif action['args']['source'] == \"discard_pile\":\n            game_reward *= 0.9  # Drawing from discard might benefit opponents\n\n    # Always ensure result is between 0 and 1\n    result_score = max(0, min(1, game_reward))\n    \n    return result_score\n",
        "\ndef score(state: dict, action: dict) -> float:\n    def card_value(card):\n        # Assigning value to cards for simplicity; rank order is predefined, so we convert to numerical for clear evaluation.\n        rank_values = {\"A\": 1, \"2\": 2, \"3\": 3, \"4\": 4, \"5\": 5, \"6\": 6, \"7\": 7, \"8\": 8, \"9\": 9, \"10\": 10, \"J\": 11, \"Q\": 12, \"K\": 13}\n        return rank_values[card[\"rank\"]]\n\n    def is_meld(cards):\n        # Check for valid melds: three or four of a kind, or sequences of same suit\n        if len(cards) < 3:\n            return False\n        suit_set = set(card['suit'] for card in cards)\n        rank_set = set(card_value(card) for card in cards)\n        if len(suit_set) == 1 and max(rank_set) - min(rank_set) == len(rank_set) - 1:\n            return True  # A valid sequence of same suit\n        if len(rank_set) == 1:\n            return True  # A valid set of same rank\n        return False\n    \n    def potential_meld_value(hand):\n        # Evaluate potential melds using hand and unseen discard pile top two\n        hand_combinations = [[hand[idx], hand[jdx]] for idx in range(len(hand)) for jdx in range(idx+1, len(hand))]\n        potential_melds = [combo + discard_top for combo in hand_combinations]\n        return sum(is_meld(meld) for meld in potential_melds)\n    \n    def unmatched_penalty(hand, action_cards):\n        # Calculate penalty for unmatched cards: Assign higher penalty with higher card ranks\n        unmatched_cards = [card for card in hand + action_cards if not is_meld([card])]\n        return sum(card_value(card) for card in unmatched_cards)\n\n    # Extract necessary components from state\n    current_player = state[\"common\"][\"current_player\"]\n    hand = state[\"players\"][current_player][\"facedown_cards\"][\"hand\"]\n    discard_pile = state[\"common\"][\"faceup_cards\"][\"discard_pile\"]\n    stock_size = state[\"common\"][\"facedown_cards\"][\"stock_size\"]\n\n    # Determine the action source and cards associated\n    if action[\"args\"][\"source\"] == \"stock\":\n        action_cards = []  # Assume random draw, treat as virtually connected\n    elif action[\"args\"][\"source\"] == \"discard_pile\":\n        action_cards = discard_pile[-2:] if len(discard_pile) >= 2 else discard_pile\n\n    # Potential meld calculation\n    potential_hand = hand + action_cards\n    base_potential_value = potential_meld_value(hand)\n    potential_meld_value = potential_meld_value(potential_hand)\n\n    # Determine increase in meld potential\n    potential_increase = potential_meld_value - base_potential_value\n\n    # Unmatched card penalties\n    penalty = unmatched_penalty(hand, action_cards)\n\n    # Calculate score: Favor actions that increase meld potential while minimizing unmatched high value penalties\n    meld_completion_likelihood = potential_increase / max(1, base_potential_value + stock_size)  # divide by potential base to prevent division by zero\n    unmatched_card_penalty = penalty / (13 * len(potential_hand))  # maximum value card times card count\n\n    # Combine into resulting score\n    result_score = meld_completion_likelihood - unmatched_card_penalty\n    result_score = max(0, min(1, result_score))  # Ensure between 0 and 1\n\n    return result_score\n",
        "\ndef score(state: dict, action: dict) -> float:\n    # Extract necessary information from the state and action\n    num_players = state['common']['num_players']\n    current_player_idx = state['common']['current_player']\n    current_player = state['players'][current_player_idx]\n    player_hand = current_player['facedown_cards']['hand']\n    legal_actions = state['legal_actions']\n    \n    # Initialize situation metrics\n    potential_meld_value = 0\n    unmatched_penalty = 0\n    opponent_interference_risk = 0\n    meld_completion_likelihood = 0\n\n    # Define high-value cards\n    high_value_cards = [\"A\", \"K\", \"Q\", \"J\", \"10\"]\n    card_values = {\"A\": 11, \"K\": 10, \"Q\": 10, \"J\": 10}\n    \n    # Assess the 'UnmatchedCardPenalty' by summing the pip values of unmatchable cards\n    for card in player_hand:\n        rank = card['rank']\n        unmatched_penalty += card_values.get(rank, int(rank) if rank.isdigit() else 10)\n            \n    # Calculate 'PotentialMeldCreationValue' based on the player's current hand\n    suits = {}\n    ranks = {}\n    for card in player_hand:\n        rank, suit = card['rank'], card['suit']\n        ranks[rank] = ranks.get(rank, 0) + 1\n        suits[suit] = suits.get(suit, 0) + 1\n    \n    for count in ranks.values():\n        if count >= 2:\n            potential_meld_value += 0.1 * count\n    \n    for count in suits.values():\n        if count >= 3:\n            potential_meld_value += 0.15 * (count - 2)\n    \n    # Determine 'MeldCompletionLikelihood'\n    for card in player_hand:\n        if card['rank'] in high_value_cards:\n            if potential_meld_value > 0.5:\n                meld_completion_likelihood += 0.3\n    \n    # Evaluate 'OpponentInterferenceRisk'\n    if state['common']['faceup_cards']['discard_pile']:  # adding this check to ensure discard pile is not empty\n        top_discard_rank = state['common']['faceup_cards']['discard_pile'][-1]['rank']\n        for opponent in state['players']:\n            if opponent != current_player:\n                if opponent['facedown_cards']['hand_size'] <= 3:  # Opponent close to winning\n                    opponent_interference_risk += 0.1\n    \n    # Determine final decision impact on game state\n    score = potential_meld_value - unmatched_penalty * 0.05 + meld_completion_likelihood - opponent_interference_risk\n    \n    # Normalize the score to a 0-1 range to represent probability of winning\n    result_score = min(1.0, max(0.0, score / num_players))\n    \n    return result_score\n"
    ]
}