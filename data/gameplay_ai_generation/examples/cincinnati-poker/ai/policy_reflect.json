{
    "game_description": "### The Pack\n\nThe standard 52-card pack is used.\n\n### Object of the Game\n\nThe goal of each player is to win the pot, which contains all the bets that the players have made in any one deal. A player makes a bet in hopes that they have the best hand, or to give the impression that they do. In most Poker versions, the top combination of five cards is the best hand.\n\n### The Deal\n\nFive cards are dealt to each player plus another hand of five cards face down on the table.\n\n### The Play\n\nCards are turned up one at a time, and there is a round of betting each time a card is exposed. Each player selects a hand of five cards from among the cards in their own hand and the five on the table.\n\n### Poker Hands\n\nFive of a Kind\u00a0-\u00a0The highest possible hand and can occur only where at least one card is wild, such as a joker. Examples of five of a kind would be four 10s and a wild card or two queens and three wild cards.\n\nStraight Flush - This is the highest possible hand when only the standard pack is used, and there are no wild cards. A straight flush consists of five cards of the same suit in sequence, such as 10, 9, 8, 7, 6 of hearts.\n\nFour of a Kind - This is the next highest hand. An example is four aces or four 3s.\n\nFull House - This colorful hand is made up of three cards of one rank and two cards of another rank, such as three 8s and two 4s.\n\nFlush - Five cards all of the same suit, but not all in sequence, is a flush. An example is Q, 10, 7, 6, and 2 of clubs.\n\nStraight - Five cards in sequence, but not all of the same suit is a straight. An example is 9\u2665, 8\u2663, 7\u2660, 6\u2666, 5\u2665.\n\nThree of a Kind - This combination contains three cards of the same rank, and the other two cards each of a different rank, such as three jacks, a seven, and a four.\n\nTwo Pairs - This hand contains a pair of one rank and another pair of a different rank, plus any fifth card of a different rank, such as Q, Q, 7, 7, 4.\n\nOne Pair - This frequent combination contains just one pair with the other three cards being of different rank. An example is 10, 10, K, 4, 3.\n\nNo Pair - This very common hand contains \"nothing.\" None of the five cards pair up, nor are all five cards of the same suit or consecutive in rank. When more than one player has no pair, the hands are rated by the highest card each hand contains, so that an ace-high hand beats a king-high hand, and so on.",
    "input_description": "Example: \n{\"common\": {\"num_players\": 4, \"current_player\": 3, \"pot\": 3000, \"current_round\": 3, \"current_bet\": 0, \"bets_in_round\": {}, \"community_cards\": {\"facedown\": [{\"rank\": \"K\", \"suit\": \"hearts\"}, {\"rank\": \"10\", \"suit\": \"clubs\"}], \"faceup\": [{\"rank\": \"K\", \"suit\": \"diamonds\"}, {\"rank\": \"2\", \"suit\": \"clubs\"}, {\"rank\": \"A\", \"suit\": \"diamonds\"}]}, \"folded_players\": [2], \"is_over\": false, \"winner\": null, \"players_to_act\": [0, 1, 3], \"last_raiser\": null, \"deck\": [{\"rank\": \"J\", \"suit\": \"diamonds\"}, {\"rank\": \"9\", \"suit\": \"diamonds\"}, {\"rank\": \"5\", \"suit\": \"hearts\"}, {\"rank\": \"6\", \"suit\": \"hearts\"}, {\"rank\": \"2\", \"suit\": \"diamonds\"}, {\"rank\": \"Q\", \"suit\": \"spades\"}, {\"rank\": \"3\", \"suit\": \"diamonds\"}, {\"rank\": \"K\", \"suit\": \"clubs\"}, {\"rank\": \"Q\", \"suit\": \"diamonds\"}, {\"rank\": \"9\", \"suit\": \"spades\"}, {\"rank\": \"3\", \"suit\": \"clubs\"}, {\"rank\": \"10\", \"suit\": \"hearts\"}, {\"rank\": \"4\", \"suit\": \"clubs\"}, {\"rank\": \"J\", \"suit\": \"spades\"}, {\"rank\": \"7\", \"suit\": \"spades\"}, {\"rank\": \"2\", \"suit\": \"spades\"}, {\"rank\": \"K\", \"suit\": \"spades\"}, {\"rank\": \"A\", \"suit\": \"spades\"}, {\"rank\": \"3\", \"suit\": \"spades\"}, {\"rank\": \"5\", \"suit\": \"diamonds\"}, {\"rank\": \"J\", \"suit\": \"hearts\"}, {\"rank\": \"9\", \"suit\": \"clubs\"}, {\"rank\": \"Q\", \"suit\": \"hearts\"}, {\"rank\": \"7\", \"suit\": \"diamonds\"}, {\"rank\": \"8\", \"suit\": \"diamonds\"}, {\"rank\": \"J\", \"suit\": \"clubs\"}, {\"rank\": \"3\", \"suit\": \"hearts\"}]}, \"players\": [{\"public\": {\"bets_made\": 0, \"chips\": 0}, \"facedown_cards\": {}, \"faceup_cards\": {}}, {\"public\": {\"bets_made\": 0, \"chips\": 0}, \"facedown_cards\": {}, \"faceup_cards\": {}}, {\"public\": {\"bets_made\": 0, \"chips\": 1000}, \"facedown_cards\": {}, \"faceup_cards\": {}}, {\"public\": {\"bets_made\": 0, \"chips\": 0, \"current_player\": true}, \"private\": {\"hand\": [{\"rank\": \"4\", \"suit\": \"hearts\"}, {\"rank\": \"A\", \"suit\": \"clubs\"}, {\"rank\": \"6\", \"suit\": \"clubs\"}, {\"rank\": \"10\", \"suit\": \"diamonds\"}, {\"rank\": \"Q\", \"suit\": \"clubs\"}]}, \"facedown_cards\": {}, \"faceup_cards\": {}}], \"recent_history\": [{\"type\": \"action\", \"player_id\": 3, \"action\": {\"action\": \"call\", \"id\": 0}, \"msg\": \"Player 3 decides to: call\"}, {\"type\": \"info\", \"msg\": \"Player 3 action: {'action': 'call', 'id': 0}\", \"role\": null}, {\"type\": \"info\", \"msg\": \"Player 3 calls 1000.\", \"role\": null}, {\"type\": \"info\", \"msg\": \"All players are checking or out of chips. Forcing round progression.\", \"role\": null}, {\"type\": \"info\", \"msg\": \"Revealed community card: K of diamonds.\", \"role\": null}, {\"type\": \"turn_end\", \"player_id\": 3, \"msg\": \"---------- End of Player 3's turn ----------\"}, {\"type\": \"action\", \"player_id\": 0, \"action\": {\"action\": \"check\", \"id\": 0}, \"msg\": \"Player 0 decides to: check\"}, {\"type\": \"info\", \"msg\": \"Player 0 action: {'action': 'check', 'id': 0}\", \"role\": null}, {\"type\": \"info\", \"msg\": \"Player 0 checks.\", \"role\": null}, {\"type\": \"info\", \"msg\": \"All players are checking or out of chips. Forcing round progression.\", \"role\": null}, {\"type\": \"info\", \"msg\": \"Revealed community card: 2 of clubs.\", \"role\": null}, {\"type\": \"turn_end\", \"player_id\": 0, \"msg\": \"---------- End of Player 0's turn ----------\"}, {\"type\": \"action\", \"player_id\": 1, \"action\": {\"action\": \"check\", \"id\": 0}, \"msg\": \"Player 1 decides to: check\"}, {\"type\": \"info\", \"msg\": \"Player 1 action: {'action': 'check', 'id': 0}\", \"role\": null}, {\"type\": \"info\", \"msg\": \"Player 1 checks.\", \"role\": null}, {\"type\": \"info\", \"msg\": \"All players are checking or out of chips. Forcing round progression.\", \"role\": null}, {\"type\": \"info\", \"msg\": \"Revealed community card: A of diamonds.\", \"role\": null}], \"legal_actions\": [{\"action\": \"check\", \"id\": 0}]}\n\nExplanation: \n{\"common\": \"An object containing information shared among all players.\", \"common.num_players\": \"The total number of players in the game.\", \"common.current_player\": \"Index of the player whose turn it is to act.\", \"common.pot\": \"Amount of chips currently in the game pot.\", \"common.current_round\": \"The current round of the game, which indicates how many community cards have been revealed so far.\", \"common.current_bet\": \"The current highest bet amount in the ongoing round.\", \"common.bets_in_round\": \"An object tracking the amount each player has bet in the current round.\", \"common.community_cards\": \"An object containing community cards information.\", \"common.community_cards.facedown\": \"A list of community cards that are facedown on the table.\", \"common.community_cards.faceup\": \"A list of community cards that are faceup on the table.\", \"common.folded_players\": \"An array containing indices of players who have folded.\", \"common.is_over\": \"A boolean indicating whether the game is over.\", \"common.winner\": \"The index of the winning player if the game is over; otherwise, null.\", \"common.players_to_act\": \"A list of indices of players who still have actions left to make in the current round.\", \"common.last_raiser\": \"Index of the last player who raised in the current betting round; otherwise, null.\", \"common.deck\": \"A list of LLMCard objects representing the remaining cards in the deck.\", \"players\": \"An array containing objects of each player's state.\", \"players[i].public.bets_made\": \"The amount of chips a player has bet in the game so far.\", \"players[i].public.chips\": \"The number of chips a player currently has.\", \"players[i].public.current_player\": \"An optional boolean field indicating if it's currently this player's turn.\", \"players[i].private.hand\": \"A list of LLMCard objects representing the player's private hand.\", \"recent_history\": \"A list of recent actions and events in the game.\", \"recent_history[i].type\": \"The type of record, e.g., 'action', 'info', 'turn_end'.\", \"recent_history[i].player_id\": \"The ID of the player related to the action or information.\", \"recent_history[i].action\": \"Details of the action taken, including action type and any additional parameters.\", \"recent_history[i].msg\": \"A message describing the associated action or event.\", \"legal_actions\": \"A list of possible actions available to the current player.\", \"legal_actions[i].action\": \"The type of action available, e.g., 'check', 'call', 'raise', 'fold'.\"}",
    "policy_list": [
        "**Aggressive Betting - Refined Strategy**\nAn enhanced 'Aggressive Betting' strategy employs continuous assessment of relevant game state metrics, allowing the AI to make informed decisions about when to intensify betting to maximize its chance of winning the pot. The AI will issue high bets when it has a strong hand, or calculates that an aggressive stance could lead to a successful bluff, by being constantly mindful of 'Hand Strength', 'Potential Improvement', 'Pot Odds', and 'Bluffing Potential'. These metrics ensure the AI's decisions are not only assertive but backed by evaluative data reflecting the present game situation.",
        "**Optimal Hand Selection Refined**\nRefined Strategy: The AI will continuously evaluate the hand strength using both its own cards and the face-up cards. Each time a card is turned up, the AI recalculates the potential hand ranking ('No Pair' to 'Five of a Kind') in context with the exposed cards. The AI uses Potential Improvement metrics to determine the probability of enhancing the hand with the remaining face-down cards, informing whether it should increase aggression in betting or play conservatively. Pot Odds guide immediate betting decisions; if the hand has high potential but requires significant investment to improve, the AI assesses the pot odds to ensure positive expected value. Additionally, the Bluffing Potential metric is examined throughout, especially when the AI's current hand is not strong, yet the game situation provides opportunities to leverage opponent weaknesses. This conditioning allows for a dynamic selection process, ensuring the AI player adapts its decisions to maintain the best possible chance of winning the pot.",
        "**Refined Bluff with Strategic Card Turn**\nTo refine the strategy of the AI flipping a card to enhance the bluffing situation, the AI should target specific game moments where the Hand Strength is lower than desired but can potentially appear formidable to opponents. Evaluating Pot Odds to ensure that the reward of bluffing justifies the risk is crucial. Additionally, the AI should constantly assess opponents' reactions and adjust the bluffing strategy by considering past betting patterns and immediate table dynamics. The AI will specifically select cards to flip when there's an opportunity to complete or imply strong hands like flushes or straights, leveraging high Bluffing Potential to manipulate opponents' bet decisions.",
        "**Refined Adaptive Betting Patterns**\nThe refined strategy involves the AI evaluating its hand strength using the 'Hand Strength' metric each time a new card is revealed. If the AI's hand is strong or has potential for significant improvement (using 'Potential Improvement'), it should consider aggressive betting. The AI must assess 'Pot Odds' to decide if staying in the hand is beneficial. When the odds are in favor, but the hand is not strong, the 'Bluffing Potential' metric should be evaluated to decide on bluffing. The AI adjusts based on historical betting patterns of opponents, betting more when opponents show weakness or folding in response to strong bets when the AI's hand is weak. At critical moments, such as near the last card reveal or when a betting round could eliminate opponents, the AI must leverage all metrics to either consolidate winnings or minimize losses."
    ],
    "code": [
        "\ndef score(state: dict, action: str) -> float:\n    rank_values = {'2': 2, '3': 3, '4': 4, '5': 5, '6': 6, '7': 7, '8': 8, '9': 9, '10': 10, 'J': 11, 'Q': 12, 'K': 13, 'A': 14}\n\n    def evaluate_hand(players_hand, community_hand):\n        all_cards = players_hand + community_hand\n\n        rank_count = {}\n        suit_count = {}\n        for card in all_cards:\n            rank_count[card['rank']] = rank_count.get(card['rank'], 0) + 1\n            suit_count[card['suit']] = suit_count.get(card['suit'], 0) + 1\n\n        flush = max(suit_count.values()) >= 5\n        sorted_values = sorted([rank_values[card['rank']] for card in all_cards], reverse=True)\n        straight = len(sorted_values) >= 5 and all(sorted_values[i] - 1 == sorted_values[i + 1] for i in range(4))\n\n        if flush and straight:\n            return 'Straight Flush'\n        elif 5 in rank_count.values():\n            return 'Five of a Kind'\n        elif 4 in rank_count.values():\n            return 'Four of a Kind'\n        elif 3 in rank_count.values() and 2 in rank_count.values():\n            return 'Full House'\n        elif flush:\n            return 'Flush'\n        elif straight:\n            return 'Straight'\n        elif 3 in rank_count.values():\n            return 'Three of a Kind'\n        elif list(rank_count.values()).count(2) == 2:\n            return 'Two Pairs'\n        elif 2 in rank_count.values():\n            return 'One Pair'\n        else:\n            return 'No Pair'\n\n    def calculate_hand_strength(hand_type):\n        hand_strengths = {\n            'Straight Flush': 0.95,\n            'Five of a Kind': 0.90,\n            'Four of a Kind': 0.85,\n            'Full House': 0.80,\n            'Flush': 0.75,\n            'Straight': 0.70,\n            'Three of a Kind': 0.65,\n            'Two Pairs': 0.60,\n            'One Pair': 0.55,\n            'No Pair': 0.50\n        }\n        return hand_strengths.get(hand_type, 0.50)\n\n    def calculate_pot_odds(game_state):\n        current_bet = game_state['common']['current_bet']\n        pot = game_state['common']['pot']\n        if current_bet == 0:\n            return 1.0\n        return pot / (pot + current_bet) if current_bet else 1.0\n\n    def evaluate_bluffing_potential(game_state, action):\n        if action in ['raise', 'bet'] and len(game_state['common']['players_to_act']) > 1:\n            return 0.7\n        elif action == 'check':\n            return 0.8\n        elif action == 'call':\n            return 0.6\n        else:\n            return 0.5\n\n    player_hand = state['players'][state['common']['current_player']]['private']['hand']\n    community_hand = state['common']['community_cards']['faceup']\n\n    hand_type = evaluate_hand(player_hand, community_hand)\n    hand_strength = calculate_hand_strength(hand_type)\n    pot_odds = calculate_pot_odds(state)\n    bluffing_potential = evaluate_bluffing_potential(state, action)\n\n    result_score = (hand_strength * 0.5) + (pot_odds * 0.3) + (bluffing_potential * 0.2)\n    \n    return result_score\n",
        "\ndef score(state: dict, action: str) -> float:\n    import random\n    \n    # Extract useful information from the game state\n    common_info = state.get(\"common\", {})\n    player_info = state.get(\"players\", [])[common_info.get(\"current_player\", 0)]\n    community_cards = common_info.get(\"community_cards\", {})\n    faceup_cards = community_cards.get(\"faceup\", [])\n    private_hand = player_info.get(\"private\", {}).get(\"hand\", [])\n    \n    # Calculate the known strength of the hand based on current available cards\n    def evaluate_hand(hand):\n        values = {'2': 2, '3': 3, '4': 4, '5': 5, '6': 6, '7': 7, '8': 8, '9': 9, '10': 10, \n                  'J': 11, 'Q': 12, 'K': 13, 'A': 14}\n        score = sum(values[card['rank']] for card in hand)\n        return score / (5 * 14)  # Normalize score to [0, 1] assuming high card evaluation\n    \n    # Simply estimating potential improvement with a stand-in for more developed logic\n    potential_improvement = random.random() * 0.2 \n\n    # Known best hand without including face-down cards\n    current_strength = evaluate_hand(private_hand + faceup_cards)\n    \n    # Assess risk-adjusted bet reasoning based on pot odds or known game dynamics\n    pot_odds = common_info.get(\"pot\", 0) / max((common_info.get(\"current_bet\", 1), 1))\n    risk_factor = 1 / (1 + pot_odds)  # Simplified risk assessment factor\n    \n    # Final probability score\n    result_score = current_strength + potential_improvement * risk_factor\n    \n    result_score = max(0.0, min(result_score, 1.0))  # Ensuring it's within 0 and 1\n    \n    return result_score\n",
        "\ndef score(state: dict, action: str) -> float:\n    def hand_strength(hand, community_cards_faceup):\n        # Calculate hand strength as a basic example\n        # This simplistic version just counts pairs or higher\n        all_cards = hand + community_cards_faceup\n        rank_count = {}\n        for card in all_cards:\n            if card['rank'] not in rank_count:\n                rank_count[card['rank']] = 0\n            rank_count[card['rank']] += 1\n        pairs = [rank for rank, count in rank_count.items() if count == 2]\n        three_of_a_kinds = [rank for rank, count in rank_count.items() if count == 3]\n        four_of_a_kinds = [rank for rank, count in rank_count.items() if count == 4]\n        \n        if four_of_a_kinds:\n            return 0.9  # Simplified as a strong hand\n        elif three_of_a_kinds and pairs:\n            return 0.85  # Full House\n        elif len(three_of_a_kinds) > 0:\n            return 0.7\n        elif len(pairs) >= 2:\n            return 0.5\n        elif len(pairs) == 1:\n            return 0.3\n        else:\n            return 0.1\n\n    def bluffing_potential(state, hand_strength):\n        # Assess bluffing opportunities based on opponents and pot odds\n        num_players = state['common']['num_players']\n        pot = state['common']['pot']\n        current_bet = state['common']['current_bet']\n\n        # Simple potential calculation\n        # Assume the potential grows with more players and a sizable pot\n        potential = (pot / (current_bet + 1)) / num_players\n        potential = min(0.9, max(0.1, potential))  # Clamp to 0.1 - 0.9\n\n        # Adjust based on hand strength\n        if hand_strength < 0.3:  # Weak hand, require aggressive bluffing\n            return min(0.5, potential + 0.2)\n        return potential\n\n    # Get the player's hand\n    player_index = state['common']['current_player']\n    player_hand = state['players'][player_index]['private']['hand']\n    community_cards_faceup = state['common']['community_cards']['faceup']\n\n    # Evaluate hand strength\n    strength = hand_strength(player_hand, community_cards_faceup)\n\n    # Calculate bluffing potential\n    bluff_potential = bluffing_potential(state, strength)\n\n    # Incorporate the action into the decision (simplified)\n    if action == 'raise':\n        result_score = bluff_potential + strength / 2.0\n    elif action == 'call':\n        result_score = (strength + bluff_potential) / 1.5\n    elif action == 'check':\n        result_score = strength\n    elif action == 'fold':\n        result_score = 0.0  # Immediate loss\n\n    # Ensure the score is between 0 and 1\n    result_score = max(0.0, min(1.0, result_score))\n\n    return result_score\n",
        "\ndef score(state: dict, action: str) -> float:\n    from collections import Counter\n\n    # Helper within scope\n    def compute_hand_strength(player_hand, faceup_cards):\n        combined_hand = player_hand + faceup_cards\n        rank_counter = Counter([card['rank'] for card in combined_hand])\n        suit_counter = Counter([card['suit'] for card in combined_hand])\n\n        # Check straight logic helpers directly placed in evaluation\n        def is_flush():\n            return max(suit_counter.values()) >= 5\n\n        def is_straight():\n            rank_order = '23456789TJQKA'\n            ranks = set(card['rank'] for card in combined_hand)\n            rank_str = ''.join(sorted(ranks, key=lambda x: rank_order.index(x)))\n            return any(rank_str[i:i+5] in rank_order for i in range(len(rank_str) - 4))\n        \n        five_of_kind = max(rank_counter.values()) == 5\n        four_of_kind = max(rank_counter.values()) == 4\n        full_house = set(rank_counter.values()) == {3, 2}\n        three_of_kind = 3 in rank_counter.values() and not full_house\n        two_pair = list(rank_counter.values()).count(2) == 2\n        one_pair = 2 in rank_counter.values() and not two_pair\n\n        if five_of_kind:\n            return 1.0\n        elif is_flush() and is_straight():\n            return 0.95\n        elif four_of_kind:\n            return 0.9\n        elif full_house:\n            return 0.8\n        elif is_flush():\n            return 0.7\n        elif is_straight():\n            return 0.6\n        elif three_of_kind:\n            return 0.5\n        elif two_pair:\n            return 0.4\n        elif one_pair:\n            return 0.3\n        else:\n            return 0.1\n\n    def calculate_pot_odds(common):\n        current_bet = common[\"current_bet\"]\n        pot = common[\"pot\"]\n        if current_bet == 0:\n            return 0.5\n        return current_bet / (current_bet + pot)\n\n    current_player_index = state[\"common\"][\"current_player\"]\n    current_player = state[\"players\"][current_player_index]\n    player_hand = current_player[\"private\"][\"hand\"]\n    faceup_cards = state[\"common\"][\"community_cards\"][\"faceup\"]\n\n    hand_strength = compute_hand_strength(player_hand, faceup_cards)\n    pot_odds = calculate_pot_odds(state[\"common\"])\n\n    action_score_mapping = {\n        \"check\": 0.2,\n        \"call\": 0.4,\n        \"raise\": 0.6,\n        \"fold\": 0.0\n    }\n    action_score = action_score_mapping.get(action, 0.0)\n\n    result_score = hand_strength * (1 - pot_odds) + action_score * pot_odds\n    return result_score\n"
    ]
}