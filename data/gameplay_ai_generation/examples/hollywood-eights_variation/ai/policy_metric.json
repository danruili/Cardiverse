{
    "game_description": "## Card Merge Challenge: Refined Ruleset\n\n### 1. **Game State**\n\n#### **Common Information:**\n- **Stock Pile:** Cards remaining in the draw pile.\n- **Starter Pile:** Top card visible to all players.\n- **Player Order:** Determined at the beginning of the game, visible to all.\n\n#### **Player-Specific Information:**\n- **Public:**\n  - **Merged Sequences:** Sequences successfully completed by all players and visible to all.\n  - **Scoreboard:** Cumulative points of each player.\n- **Private:**\n  - **Player Hand:** Cards held by each player, visible only to themselves.\n\n---\n\n### 2. **Card**\n\n#### **Attributes:**\n- **Rank:** One of {A, 2, 3, 4, 5, 6, 7, 9, 10, J, Q, K}.\n- **Suit:** One of {Hearts, Diamonds, Clubs, Spades}.\n- **Unique Symbol:** A special symbol on each card for merging purposes.\n- **Special Card:** Eight acts as a wild card for both suit and symbol changes.\n\n---\n\n### 3. **Deck and Initial Dealing**\n\n#### **Deck Composition:**\n- A standard 52-card deck with additional unique symbols on each card.\n\n#### **Initial Dealing:**\n- Deal five cards face down to each player.\n- Remaining cards form the stock pile.\n- Top card of the stock pile is turned up to start the starter pile. If this is an eight, it is inserted into the deck, and another card is drawn.\n\n---\n\n### 4. **Legal Action Space**\n\n#### **On a Turn, a Player May:**\n1. **Play a Card:**\n   - Place one card from their hand on the starter pile.\n   - Prerequisite: The card must match the top card by rank, suit, or symbol.\n2. **Merge Sequence:**\n   - Create a sequence with the top card of the starter pile combined with cards from the player's hand.\n   - Required: Sequence of three or more cards sharing a common symbol.\n   - Additional Rule: Only one merged sequence can be created per turn.\n3. **Use Wild Card (Eight):**\n   - Play an eight to change suit and symbol trajectory.\n4. **Draw a Card:**\n   - Draw from the stock if they can\u2019t play, OR opt to strategically draw despite alternatives.\n   - Prerequisite: No matching card in hand, or by strategic choice.\n\n---\n\n### 5. **Round**\n\n#### **Sequence of Play:**\n1. Player left of the dealer starts.\n2. Turns proceed in clockwise order.\n3. During a turn, a player:\n   - Plays a card or merges.\n   - Draws a card (if needed).\n   - The turn ends and passes to the next player.\n4. Play continues until:\n   - A player reaches 150 points through merges and regular gameplay.\n\n#### **Winning Conditions:**\n- A player wins upon reaching 150 points through successful merges and card play.\n\n---\n\n### 6. **Other Game Mechanics & Rules**\n\n- **Merge Bonus:** Successfully merging a sequence grants a 10-point bonus per card in the sequence.\n- **Wild Card Usage:** Eights alter game flow, allowing suit and symbol changes for new sequence formation.\n- **Score Recording:** Results recorded across up to four ongoing games, scoring detailed sequentially.\n\n---\n\n### 7. **Player Observation Information**\n\n#### **Visible Information to Each Player:**\n- The top card of the starter pile.\n- Merged sequences on the table.\n- Cumulative scores of all players.\n\n#### **Hidden Information:**\n- Identity of cards in the stock pile.\n- Cards in opponents' hands.\n\n---\n\n### 8. **Payoffs**\n\n#### **Endgame Scoring:**\n- Points awarded for each merged sequence:\n  - Each successful merge contributes to the score based on the number of cards in the sequence.\n  - Align scoring with the traditional logic: Face cards = 10 points; Eights = 20 points; Ace = 15 points; Numbered cards = Pip value.\n\n#### **Objective Achievement:**\n- Game winner is the first to score 150 points through strategic merging and regular gameplay, leveraging visible and hidden game states smartly.\n\nThis refined description ensures the gameplay mechanics are well-aligned with the new merging objective and special card function, providing clarity and ensuring strategic depth.",
    "input_description": "Example: \n{\"common\": {\"num_players\": 4, \"current_player\": 2, \"winner\": null, \"is_over\": false, \"starter_pile\": {\"top_card\": {\"rank\": \"8\", \"suit\": \"diamonds\", \"symbol\": \"8\"}}, \"facedown_cards\": {\"stock_size\": 29}, \"discard_pile\": [{\"rank\": \"J\", \"suit\": \"spades\", \"symbol\": \"J\"}, {\"rank\": \"J\", \"suit\": \"hearts\", \"symbol\": \"J\"}, {\"rank\": \"2\", \"suit\": \"hearts\", \"symbol\": \"2\"}, {\"rank\": \"Q\", \"suit\": \"hearts\", \"symbol\": \"Q\"}]}, \"players\": [{\"public\": {\"score\": 0, \"merged_sequences\": []}, \"facedown_cards\": {\"hand_size\": 3}}, {\"public\": {\"score\": 0, \"merged_sequences\": []}, \"facedown_cards\": {\"hand_size\": 7}}, {\"public\": {\"score\": 0, \"merged_sequences\": [], \"current_player\": true}, \"facedown_cards\": {\"hand\": [{\"rank\": \"K\", \"suit\": \"clubs\", \"symbol\": \"K\"}, {\"rank\": \"6\", \"suit\": \"hearts\", \"symbol\": \"6\"}, {\"rank\": \"7\", \"suit\": \"spades\", \"symbol\": \"7\"}, {\"rank\": \"Q\", \"suit\": \"diamonds\", \"symbol\": \"Q\"}]}}, {\"public\": {\"score\": 0, \"merged_sequences\": []}, \"facedown_cards\": {\"hand_size\": 4}}], \"recent_history\": [{\"type\": \"action\", \"player_id\": 2, \"action\": {\"action\": \"play\", \"args\": {\"card_idx\": 0}, \"id\": 0}, \"msg\": \"Player 2 decides to: play-(card_idx: 0)\"}, {\"type\": \"info\", \"msg\": \"Player 2 plays 2-hearts-2 onto the starter pile.\", \"role\": null}, {\"type\": \"turn_end\", \"player_id\": 2, \"msg\": \"---------- End of Player 2's turn ----------\"}, {\"type\": \"action\", \"player_id\": 3, \"action\": {\"action\": \"play\", \"args\": {\"card_idx\": 1}, \"id\": 0}, \"msg\": \"Player 3 decides to: play-(card_idx: 1)\"}, {\"type\": \"info\", \"msg\": \"Player 3 plays Q-hearts-Q onto the starter pile.\", \"role\": null}, {\"type\": \"turn_end\", \"player_id\": 3, \"msg\": \"---------- End of Player 3's turn ----------\"}, {\"type\": \"action\", \"player_id\": 0, \"action\": {\"action\": \"use_wild\", \"args\": {\"card_idx\": 1, \"new_suit\": \"spades\"}, \"id\": 3}, \"msg\": \"Player 0 decides to: use_wild-(card_idx: 1, new_suit: spades)\"}, {\"type\": \"info\", \"msg\": \"Player 0 uses a wild card to change the suit to spades.\", \"role\": null}, {\"type\": \"turn_end\", \"player_id\": 0, \"msg\": \"---------- End of Player 0's turn ----------\"}, {\"type\": \"action\", \"player_id\": 1, \"action\": {\"action\": \"draw\", \"id\": 0}, \"msg\": \"Player 1 decides to: draw\"}, {\"type\": \"info\", \"msg\": \"Player 1 draws a card from the stock.\", \"role\": null}], \"legal_actions\": [{\"action\": \"play\", \"args\": {\"card_idx\": 2}, \"id\": 0}]}\n\nExplanation: \n{\"common\": \"A section storing information shared among all players.\", \"common.num_players\": \"The total number of players in the game.\", \"common.current_player\": \"The index of the player whose turn it is currently.\", \"common.winner\": \"The index of the player who has won the game, if the game is over; otherwise null.\", \"common.is_over\": \"A boolean indicating if the game has ended.\", \"common.starter_pile\": \"A section storing details of the pile where the top card is placed.\", \"common.starter_pile.top_card\": \"The top card of the starter pile, represented as a dictionary with rank, suit, and symbol.\", \"common.facedown_cards\": \"A section containing facedown cards not visible to players, like the stock of available cards.\", \"common.facedown_cards.stock_size\": \"The number of cards remaining in the stock.\", \"common.discard_pile\": \"A list of cards that have been played and discarded from the starter pile.\", \"players\": \"An array where each element holds details about a specific player.\", \"players[].public\": \"Information visible to all players for each specific player.\", \"players[].public.score\": \"The total score of the player.\", \"players[].public.merged_sequences\": \"A list of sequences of cards the player has successfully merged.\", \"players[].facedown_cards\": \"Details of the cards a player holds in their hand.\", \"players[].facedown_cards.hand_size\": \"The number of cards in a player's hand when the actual cards aren't provided.\", \"players[].facedown_cards.hand\": \"A list of cards held by the current player, visible in detail.\", \"recent_history\": \"A list of recent actions taken in the game, presented chronologically.\", \"recent_history[].type\": \"The type of event recorded in the history, such as 'action', 'info', or 'turn_end'.\", \"recent_history[].player_id\": \"The index of the player executing the action or event being recorded.\", \"recent_history[].action\": \"Details of the action taken by a player, including the action type and any necessary arguments.\", \"recent_history[].msg\": \"A message describing the action or event in prose.\", \"recent_history[].role\": \"Typically null in this context, but might reference who's affected by an action in other instances.\", \"legal_actions\": \"A list of the actions currently available to the current player.\", \"legal_actions[].action\": \"The type of action a player can take, e.g., 'play', 'draw'.\", \"legal_actions[].args\": \"Any arguments necessary to perform the action, such as indices for card selection.\"}",
    "policy_list": [
        "**Potential Merge Value**\nThis metric evaluates the potential points that can be gained from merging a sequence using the top card of the starter pile and cards in hand. It considers the number of cards in the sequence and their corresponding point values. Higher values indicate a more valuable merging opportunity.",
        "**Avoidance Risk Factor**\nThis metric measures the risk of not being able to play a card on subsequent turns by evaluating the diversity and flexibility of the player's hand. A higher risk factor indicates a higher chance of getting stuck, prompting the player to draw more strategically.",
        "**Wild Card Utility**\nThis metric assesses the strategic utility of playing an eight as a wild card to change the suit and symbol heading of the game. It is calculated based on how many potential sequences the player can create or disrupt using the wild card.",
        "**Opponent Interference Potential**\nThis metric evaluates the likelihood that a play can interfere with opponents' strategies. It considers factors such as the frequency of specific ranks, suits, or symbols in previously played cards, estimating the disruption it would cause to other players' potential merges."
    ],
    "code": [
        "\ndef score(state: dict, action: dict) -> float:\n    # Define helper functions to calculate the potential merge score\n    def card_value(card):\n        if card['rank'] in ['J', 'Q', 'K']:\n            return 10\n        elif card['rank'] == 'A':\n            return 15\n        elif card['rank'] == '8':  # Wild cards have a higher value\n            return 20\n        else:\n            return int(card['rank'])\n\n    def calculate_merge_value(hand, starter_card):\n        # Identify cards in hand that can be part of a merge sequence\n        matching_cards = [card for card in hand if card['symbol'] == starter_card['symbol']]\n        # Calculate potential points if a merge sequence can be formed (3+ cards)\n        if len(matching_cards) >= 2:  # 2 cards in hand + 1 from starter = 3\n            merge_sequence = [starter_card] + matching_cards[:2]\n            return sum(card_value(card) for card in merge_sequence) + len(merge_sequence) * 10  # Merge bonus\n        return 0\n\n    # Get current player's information\n    current_player_index = state['common']['current_player']\n    current_player = state['players'][current_player_index]\n    \n    # Extract relevant game state data\n    starter_card = state['common']['starter_pile']['top_card']\n    player_hand = current_player['facedown_cards'].get('hand', [])\n\n    # Initialize reward with a baseline chance\n    result_score = 0.5  \n\n    # Determine if action is a play or merge and calculate its potential\n    if action['action'] == 'play':\n        card_idx = action['args']['card_idx']\n        played_card = player_hand[card_idx]\n        # Check if playing the card leads to a advantageous state (merge potential)\n        if (played_card['rank'] == starter_card['rank'] or \n            played_card['suit'] == starter_card['suit'] or \n            played_card['symbol'] == starter_card['symbol']):\n            # Potential increased by higher card value\n            result_score += card_value(played_card) / 100 \n        \n    elif action['action'] == 'merge_sequence':\n        # Calculate the improved potential from merging given the state and action\n        merge_value = calculate_merge_value(player_hand, starter_card)\n        if merge_value > 0:\n            result_score += merge_value / 150  # Normalize against winning condition\n    \n    # Adjust result_score within [0, 1] bounds\n    return min(max(result_score, 0), 1)\n\n# Example state and action\nexample_state = {\n    \"common\": {\n        \"num_players\": 4,\n        \"current_player\": 2,\n        \"winner\": None,\n        \"is_over\": False,\n        \"starter_pile\": {\n            \"top_card\": {\n                \"rank\": \"8\",\n                \"suit\": \"diamonds\",\n                \"symbol\": \"8\"\n            }\n        },\n        \"facedown_cards\": {\n            \"stock_size\": 29\n        },\n        \"discard_pile\": [\n            {\"rank\": \"J\", \"suit\": \"spades\", \"symbol\": \"J\"},\n            {\"rank\": \"J\", \"suit\": \"hearts\", \"symbol\": \"J\"},\n            {\"rank\": \"2\", \"suit\": \"hearts\", \"symbol\": \"2\"},\n            {\"rank\": \"Q\", \"suit\": \"hearts\", \"symbol\": \"Q\"}\n        ]\n    },\n    \"players\": [\n        {\"public\": {\"score\": 0, \"merged_sequences\": []}, \"facedown_cards\": {\"hand_size\": 3}},\n        {\"public\": {\"score\": 0, \"merged_sequences\": []}, \"facedown_cards\": {\"hand_size\": 7}},\n        {\"public\": {\"score\": 0, \"merged_sequences\": [], \"current_player\": True}, \"facedown_cards\": {\"hand\": [\n            {\"rank\": \"K\", \"suit\": \"clubs\", \"symbol\": \"K\"},\n            {\"rank\": \"6\", \"suit\": \"hearts\", \"symbol\": \"6\"},\n            {\"rank\": \"7\", \"suit\": \"spades\", \"symbol\": \"7\"},\n            {\"rank\": \"Q\", \"suit\": \"diamonds\", \"symbol\": \"Q\"}\n        ]}},\n        {\"public\": {\"score\": 0, \"merged_sequences\": []}, \"facedown_cards\": {\"hand_size\": 4}}\n    ],\n    \"recent_history\": [],\n    \"legal_actions\": [\n        {\"action\": \"play\", \"args\": {\"card_idx\": 2}, \"id\": 0}\n    ]\n}\n\nexample_action = {\"action\": \"play\", \"args\": {\"card_idx\": 2}}\n\n# Call the function with an example\n#print(score(example_state, example_action))  # Expected an output value in range [0, 1]\n",
        "\ndef score(state: dict, action: dict) -> float:\n    # Example basic contributing factors for the score outcome\n\n    # Extract current player's information\n    current_player_index = state['common']['current_player']\n    current_player = state['players'][current_player_index]\n    hand_cards = current_player['facedown_cards'].get('hand', [])\n    score = current_player['public']['score']\n\n    # Extract information on top card of the starter pile\n    top_card = state['common']['starter_pile']['top_card']\n    # Special card which could be more advantageous\n    wild_card_rank = '8'\n    \n    # Calculate flexible playability score\n    playable_cards = sum(\n        1 for card in hand_cards\n        if card['rank'] == top_card['rank'] or \n           card['suit'] == top_card['suit'] or \n           card['symbol'] == top_card['symbol'] or \n           card['rank'] == wild_card_rank\n    )\n    \n    # Avoidance Risk Factor - how many cards a player has that can be directly played\n    hand_size = len(hand_cards)\n    avoidance_risk_factor = 1 - (playable_cards / hand_size) if hand_size > 0 else 1\n\n    # Score contribution from current score\n    score_contribution = score / 150.0\n\n    # Factor in legal actions available (basic heuristics)\n    num_legal_actions = len(state['legal_actions'])\n    legal_action_contribution = num_legal_actions / 4.0  # Assuming max 4 types of actions for variety\n\n    # Calculate the result score based on heuristic contributions\n    result_score = (\n        0.4 * score_contribution +\n        0.3 * (1 - avoidance_risk_factor) +\n        0.3 * legal_action_contribution\n    )\n\n    # Ensure result is between 0 and 1\n    result_score = max(0.0, min(1.0, result_score))\n\n    return result_score\n",
        "\ndef score(state: dict, action: dict) -> float:\n    def calculate_wild_card_utility(hand, starter_pile_top):\n        suits = {\"hearts\", \"diamonds\", \"clubs\", \"spades\"}\n        symbols = {card['symbol'] for card in hand}\n        utility = 0\n\n        for suit in suits:\n            if suit != starter_pile_top['suit']:\n                utility += 1\n                utility += sum(1 for card in hand if card['symbol'] in symbols and card['suit'] == suit)\n\n        return utility / len(suits)\n\n    # Evaluate the given action\n    current_player = state['common']['current_player']\n    player_hand = state['players'][current_player]['facedown_cards']['hand']\n    top_card = state['common']['starter_pile']['top_card']\n\n    # If the action is to use a wild card:\n    if action['action'] == 'use_wild':\n        utility_score = calculate_wild_card_utility(player_hand, top_card)\n        result_score = min(max(utility_score, 0), 1)\n    else:\n        result_score = 0.5  # Default score for non-evaluated actions\n\n    return result_score\n",
        "\ndef score(state: dict, action: dict) -> float:\n    def evaluate_opponent_interference(state, action):\n        # Extract the top card from the starter pile\n        top_card = state['common']['starter_pile']['top_card']\n        \n        # Card play action details if available, with rank, suit, symbol intersections assessment.\n        played_card = None\n        if action['action'] == \"play\":\n            card_idx = action['args']['card_idx']\n            played_card = state['players'][state['common']['current_player']]['facedown_cards']['hand'][card_idx]\n\n        # Calculate the interference score for playing this card\n        interference_score = 0\n        \n        # Special case for wild card play: always a good interference\n        if played_card and played_card['rank'] == '8':\n            interference_score = 0.8\n            \n        elif played_card:\n            # Check rank interference\n            rank_interference = sum(1 for card in state['common']['discard_pile'] \n                                    if card['rank'] == played_card['rank']) / len(state['common']['discard_pile'])\n            \n            # Check suit interference\n            suit_interference = sum(1 for card in state['common']['discard_pile'] \n                                    if card['suit'] == played_card['suit']) / len(state['common']['discard_pile'])\n            \n            # Check symbol interference\n            symbol_interference = sum(1 for card in state['common']['discard_pile'] \n                                      if card['symbol'] == played_card['symbol']) / len(state['common']['discard_pile'])\n            \n            # Averaging the impact for opponent's strategies\n            interference_score = (rank_interference + suit_interference + symbol_interference) / 3\n        \n        # Normalize interference score between 0 to 0.5\n        return min(interference_score, 0.5)\n\n    # Base winning chance rooted in proximity to winning (e.g., points, strategic merges)\n    def evaluate_proximity_to_win(state):\n        current_player_state = state['players'][state['common']['current_player']]['public']\n        score = current_player_state['score']\n\n        # Normalize score to a range of 0.5 when close to winning\n        proximity_score = min(score / 150, 0.5)\n        return proximity_score\n    \n    # Evaluate overall score composed of interference and proximity\n    opponent_interference_score = evaluate_opponent_interference(state, action)\n    proximity_to_win_score = evaluate_proximity_to_win(state)\n    \n    # Aggregate scores into the final prediction\n    result_score = opponent_interference_score + proximity_to_win_score\n    result_score = min(max(result_score, 0), 1)  # Ensure value is within [0, 1]\n    \n    return result_score\n"
    ]
}