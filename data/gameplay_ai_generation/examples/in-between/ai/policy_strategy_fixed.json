{
    "game_description": "In-Between is not very popular at casinos, but is often played in home Poker games as a break from Poker itself. The rules below are for the home game, which is easily adaptable for casino play.\n\n### Rank of Cards\n\nA (high), K, Q, J, 10, 9, 8, 7, 6, 5, 4, 3, 2.\n\n### Object of the Game\n\nThe goal is to be the player with the most chips at the end of the game.\n\n### The Ante\n\nChips are distributed to the players, and each players puts one chip in the center of the table to form a pool or pot.\n\n### The Draw\n\nAny player deals one card face up, to each player in turn, and the player with the highest card deals first.\n\n### The Shuffle, Cut, and Deal\n\nAny player may shuffle, and the dealer shuffles last. The player to the dealer's right cuts the cards. The dealer turns up two cards and places them in the middle of the table, positioning them so that there is ample room for a third card to fit in between.\n\n### The Betting\n\nThe player on the dealer's left may bet up to the entire pot or any portion of the number of chips in the pot, but they must always bet a minimum of one chip. When the player has placed a bet, the dealer turns up the top card from the pack and places it between the two cards already face up. If the card ranks between the two cards already face up, the player wins and takes back the amount of his bet plus an equivalent amount from the pot. If the third card is not between the face-up cards, or is of the same rank as either of them, the player loses his bet, and it is added to the pot. If the two face-up cards up are consecutive, the player automatically loses, and a third card need not be turned up. If the two face-up cards are the same, the player wins two chips and, again, no third card is turned up. (In some games, the player is paid three chips when this occurs.)\n\n\"Acey-Deucey\" (ace, 2) is the best combination, and a player tends to bet the whole pot, if they can. This is because the only way an ace-deuce combination can lose is if the third card turned up is also an ace or a deuce.\n\nAfter the first player has finished, the dealer clears away the cards and places them face down in a pile. The next player then places a bet, and the dealer repeats the same procedure until all the players, including the dealer, have had a turn.\n\nIf at any time, the pot has no more chips in it (because a player has \"bet the pot\" and won), each player again puts in one chip to restore\u00a0the pot.\n\nWhen every player has had a turn to bet, the deal passes to the player on the dealer's left, and the game continues.",
    "input_description": "Example: \n{\"common\": {\"num_players\": 4, \"current_player\": 0, \"dealer\": 3, \"pot\": 27, \"community_cards\": {\"faceup_cards\": []}, \"facedown_cards\": {\"deck_size\": 41}, \"is_over\": false, \"winner\": null}, \"players\": [{\"public\": {\"chips\": 2, \"current_player\": true}}, {\"public\": {\"chips\": 1}}, {\"public\": {\"chips\": 7}}, {\"public\": {\"chips\": 3}}], \"recent_history\": [{\"type\": \"action\", \"player_id\": 0, \"action\": {\"action\": \"bet\", \"args\": {\"bet\": 1}, \"id\": 0}, \"msg\": \"Player 0 decides to: bet-(bet: 1)\"}, {\"type\": \"info\", \"msg\": \"Player 0's action: {'action': 'bet', 'args': {'bet': 1}, 'id': 0}\", \"role\": null}, {\"type\": \"info\", \"msg\": \"Player 0 bets 1 chips.\", \"role\": null}, {\"type\": \"info\", \"msg\": \"Third card drawn is Q-clubs.\", \"role\": null}, {\"type\": \"info\", \"msg\": \"Player 0 loses 1 chips to the pot.\", \"role\": null}, {\"type\": \"turn_end\", \"player_id\": 0, \"msg\": \"---------- End of Player 0's turn ----------\"}, {\"type\": \"action\", \"player_id\": 1, \"action\": {\"action\": \"bet\", \"args\": {\"bet\": 8}, \"id\": 7}, \"msg\": \"Player 1 decides to: bet-(bet: 8)\"}, {\"type\": \"info\", \"msg\": \"Player 1's action: {'action': 'bet', 'args': {'bet': 8}, 'id': 7}\", \"role\": null}, {\"type\": \"info\", \"msg\": \"Player 1 bets 8 chips.\", \"role\": null}, {\"type\": \"info\", \"msg\": \"Third card drawn is 8-clubs.\", \"role\": null}, {\"type\": \"info\", \"msg\": \"Player 1 loses 8 chips to the pot.\", \"role\": null}, {\"type\": \"info\", \"msg\": \"Dealer moves to player 3. Next player is 0.\", \"role\": null}], \"legal_actions\": [{\"action\": \"bet\", \"args\": {\"bet\": 1}, \"id\": 0}, {\"action\": \"bet\", \"args\": {\"bet\": 2}, \"id\": 1}]}\n\nExplanation: \n{\"common\": {\"num_players\": \"The total number of players participating in the game, an integer value.\", \"current_player\": \"The index of the player whose turn it currently is, an integer value.\", \"dealer\": \"The index of the player who is currently the dealer, an integer value.\", \"pot\": \"The total number of chips currently in the pot, an integer value.\", \"community_cards\": {\"faceup_cards\": \"A list of community cards that are currently face-up on the table. At this point, it's an empty list.\"}, \"facedown_cards\": {\"deck_size\": \"The number of cards remaining in the deck, an integer value representing the size of the deck.\"}, \"is_over\": \"A boolean indicating whether the game is over.\", \"winner\": \"The index of the player who has won the game, or null if there is no winner yet.\"}, \"players\": [{\"public\": {\"chips\": \"The number of chips that player 0 currently has, an integer value.\", \"current_player\": \"A boolean indicating if this player is the current player, only present for Player 0.\"}}, {\"public\": {\"chips\": \"The number of chips that player 1 currently has, an integer value.\"}}, {\"public\": {\"chips\": \"The number of chips that player 2 currently has, an integer value.\"}}, {\"public\": {\"chips\": \"The number of chips that player 3 currently has, an integer value.\"}}], \"recent_history\": [{\"type\": \"The type of recent event/action, such as 'action', 'info', or 'turn_end'.\", \"player_id\": \"The index of the player associated with this action or turn end, if applicable.\", \"action\": {\"action\": \"The specific type of action taken by the player (e.g., 'bet').\", \"args\": \"Additional arguments related to the action, such as bet amount.\", \"id\": \"A unique identifier for the action.\"}, \"msg\": \"A human-readable message describing the event.\", \"role\": \"The role or perspective from which the message is generated, often null.\"}, {\"type\": \"The type of recent event/action, such as 'info'.\", \"msg\": \"A human-readable message describing game information or progress.\", \"role\": \"The role or perspective from which the message is generated, often null.\"}], \"legal_actions\": [{\"action\": \"The type of legal action currently available to the current player, such as 'bet'.\", \"args\": {\"bet\": \"The amount that can be bet in this particular legal action.\"}, \"id\": \"A unique identifier for the legal action option.\"}]}",
    "policy_list": [
        "**Bet High on Wide Range**\nWhen the two face-up cards have a wide range between them, such as a 2 and a King, place a high bet close to the pot size.",
        "**Minimum Bet on Consecutive Cards**\nWhen the two face-up cards are consecutive (e.g., a 7 and an 8), bet the minimum amount required.",
        "**Bet Pot on Acey-Deucey**\nWhen the two face-up cards are an Ace and a Deuce, always bet the entire pot.",
        "**Moderate Betting on Equal Cards**\nIf the two face-up cards are of the same rank, place a moderate bet, not exceeding half the pot."
    ],
    "code": [
        "\ndef score(state: dict, action: dict) -> float:\n    # Extract necessary information from the state\n    pot_size = state[\"common\"][\"pot\"]\n    faceup_cards = state[\"common\"][\"community_cards\"][\"faceup_cards\"]\n    current_player = state[\"common\"][\"current_player\"]\n    player_chips = state[\"players\"][current_player][\"public\"][\"chips\"]\n\n    # Early return if there are not exactly two face-up cards\n    if len(faceup_cards) != 2:\n        return 0\n\n    # Map card ranks to numerical values\n    rank_map = {'A': 14, 'K': 13, 'Q': 12, 'J': 11,\n                '10': 10, '9': 9, '8': 8, '7': 7,\n                '6': 6, '5': 5, '4': 4, '3': 3, '2': 2}\n\n    # Convert ranks of the faceup cards to numerical values\n    card1_value = rank_map[faceup_cards[0]['rank']]  # Face-up card 1\n    card2_value = rank_map[faceup_cards[1]['rank']]  # Face-up card 2\n\n    # Calculate the range between faceup cards\n    card_range = abs(card1_value - card2_value)\n\n    # If the cards are consecutive, the player automatically loses\n    if card_range == 1:\n        return 0\n\n    # Maximum range for any possible faceup cards\n    max_range = 12\n\n    # Normalize range between the faceup cards to a value between 0 and 1\n    range_score = card_range / max_range\n\n    # Proportional bet size the player is planning to make, capped by pot size\n    bet_size = action[\"args\"][\"bet\"]\n    bet_proportion = min(float(bet_size) / pot_size, 1)\n\n    # Calculate the score considering the range and the bet proportion\n    result_score = range_score * bet_proportion\n\n    # Ensure result score is between 0 and 1\n    return max(0, min(1, result_score))\n\n# Example usage:\n# state = {...}  # game state as a dictionary\n# action = {\"action\": \"bet\", \"args\": {\"bet\": 2}, \"id\": 1}\n# #print(score(state, action))\n",
        "\ndef score(state: dict, action: dict) -> float:\n    # Extract necessary information from the state\n    pot = state['common']['pot']\n    current_player_id = state['common']['current_player']\n    current_player_chips = state['players'][current_player_id]['public']['chips']\n    faceup_cards = state['common']['community_cards']['faceup_cards']\n    \n    # Check if there are two face-up cards to evaluate\n    if len(faceup_cards) != 2:\n        return 0.0  # Not a valid state to compute the budget\n    \n    card1, card2 = faceup_cards[0], faceup_cards[1]\n    card_ranks = {'2': 2, '3': 3, '4': 4, '5': 5, '6': 6, '7': 7, \n                  '8': 8, '9': 9, '10': 10, 'J': 11, 'Q': 12, 'K': 13, 'A': 14}\n    \n    rank1 = card_ranks[card1['rank']]\n    rank2 = card_ranks[card2['rank']]\n    \n    # Calculate the gap between the face-up card ranks\n    gap = abs(rank1 - rank2) - 1\n    \n    # If the cards are consecutive, only the minimum bet is wise\n    if gap <= 0:\n        return 0.1  # Very low reward due to consecutive cards\n    \n    # Calculate potential win range\n    total_gap = 13  # The number of possible ranks in the deck\n    potential_win_odds = gap / total_gap\n    \n    # Consider the proposed bet\n    if 'action' in action and 'bet' in action['args']:\n        bet_amount = action['args']['bet']\n    else:\n        bet_amount = 1  # Default to minimum bet if not specified\n    \n    # Calculate a basic performance measure\n    performance_factor = bet_amount / pot if pot > 0 else 0\n\n    # Estimate reward\n    result_score = potential_win_odds * performance_factor\n\n    # Make sure the score is within the 0-1 range\n    result_score = min(max(result_score, 0.0), 1.0)\n\n    return result_score\n",
        "\ndef score(state: dict, action: dict) -> float:\n    \"\"\"\n    Estimate the probability of winning based on current game state and action.\n    \n    :param state: A dictionary containing information about the current game state.\n    :param action: A dictionary representing the planned action with action details.\n    :return: A float indicating the estimated probability of winning (0 to 1).\n    \"\"\"\n    # Extract common game details\n    pot = state['common']['pot']\n    faceup_cards = state['common']['community_cards']['faceup_cards']\n    current_player_chips = state['players'][state['common']['current_player']]['public']['chips']\n    \n    # Check if we have the Acey-Deucey condition\n    is_acey_deucey = ('A' in faceup_cards) and ('2' in faceup_cards)\n\n    # Determine the action being taken\n    are_we_betting_pot = False\n    if action['action'] == 'bet':\n        bet_amount = action['args']['bet']\n        are_we_betting_pot = (bet_amount == pot)\n    \n    # Estimate the probability of winning\n    if is_acey_deucey:\n        if are_we_betting_pot:\n            # High probability of winning with Acey-Deucey and betting full pot\n            result_score = 0.9 + 0.1 * (current_player_chips / (current_player_chips + pot))\n        else:\n            # Lower risk perceptions if not playing full pot in Acey-Deucey\n            result_score = 0.7\n    else:\n        # Standard estimation logic for non-Acey-Deucey rounds\n        result_score = 0.5\n    \n    return result_score\n",
        "\ndef score(state: dict, action: dict) -> float:\n    # Extract necessary information from the state\n    num_players = state[\"common\"][\"num_players\"]\n    current_player_id = state[\"common\"][\"current_player\"]\n    pot_size = state[\"common\"][\"pot\"]\n    faceup_cards = state[\"common\"][\"community_cards\"][\"faceup_cards\"]\n    player_chips = state[\"players\"][current_player_id][\"public\"][\"chips\"]\n    bet_amount = action[\"args\"][\"bet\"]\n\n    # Initialize the score\n    result_score = 0.1  # Start with a minimal baseline chance of winning\n\n    # Function to get the card value\n    def get_card_value(card: dict) -> int:\n        # Define Rank map\n        rank_map = {\n            'A': 14, 'K': 13, 'Q': 12, 'J': 11,\n            '10': 10, '9': 9, '8': 8, '7': 7,\n            '6': 6, '5': 5, '4': 4, '3': 3, '2': 2\n        }\n        return rank_map[card[\"rank\"]]  # Use rank key from the dictionary\n\n    # Check if the two cards are consecutive (automatic loss)\n    if faceup_cards and len(faceup_cards) == 2:\n        card_values = sorted([get_card_value(card) for card in faceup_cards])\n        if card_values[1] - card_values[0] == 1:\n            return 0.0  # Consecutive cards, automatic loss\n\n        # Check if the two face-up cards are the same\n        if card_values[0] == card_values[1]:\n            if bet_amount <= pot_size / 2:\n                result_score += 0.5  # Moderate bet scenario on equal cards\n\n    # Consider the range between the two face-up cards\n    if faceup_cards and len(faceup_cards) == 2:\n        min_card, max_card = sorted(faceup_cards, key=get_card_value)\n        card_range = get_card_value(max_card) - get_card_value(min_card) - 1\n        if card_range <= 0:\n            return 0.0  # No space in between\n\n        # Estimate the probability of hitting a card in between\n        # Considering typical number of cards remaining, deck: 52 - 2 cards\n        prob_in_between = card_range / (state[\"common\"][\"facedown_cards\"][\"deck_size\"])\n        result_score += prob_in_between * 0.8  # Scaling into our [0, 1] reward space\n\n    # Adjust for the action (bet amount)\n    bet_ratio_to_pot = bet_amount / pot_size\n    result_score *= max(0, 1 - bet_ratio_to_pot)\n\n    # Ensure the result_score is capped between 0 and 1\n    result_score = max(0, min(result_score, 1))\n    \n    return result_score\n"
    ]
}