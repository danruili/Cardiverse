{
    "game_description": "In-Between is not very popular at casinos, but is often played in home Poker games as a break from Poker itself. The rules below are for the home game, which is easily adaptable for casino play.\n\n### Rank of Cards\n\nA (high), K, Q, J, 10, 9, 8, 7, 6, 5, 4, 3, 2.\n\n### Object of the Game\n\nThe goal is to be the player with the most chips at the end of the game.\n\n### The Ante\n\nChips are distributed to the players, and each players puts one chip in the center of the table to form a pool or pot.\n\n### The Draw\n\nAny player deals one card face up, to each player in turn, and the player with the highest card deals first.\n\n### The Shuffle, Cut, and Deal\n\nAny player may shuffle, and the dealer shuffles last. The player to the dealer's right cuts the cards. The dealer turns up two cards and places them in the middle of the table, positioning them so that there is ample room for a third card to fit in between.\n\n### The Betting\n\nThe player on the dealer's left may bet up to the entire pot or any portion of the number of chips in the pot, but they must always bet a minimum of one chip. When the player has placed a bet, the dealer turns up the top card from the pack and places it between the two cards already face up. If the card ranks between the two cards already face up, the player wins and takes back the amount of his bet plus an equivalent amount from the pot. If the third card is not between the face-up cards, or is of the same rank as either of them, the player loses his bet, and it is added to the pot. If the two face-up cards up are consecutive, the player automatically loses, and a third card need not be turned up. If the two face-up cards are the same, the player wins two chips and, again, no third card is turned up. (In some games, the player is paid three chips when this occurs.)\n\n\"Acey-Deucey\" (ace, 2) is the best combination, and a player tends to bet the whole pot, if they can. This is because the only way an ace-deuce combination can lose is if the third card turned up is also an ace or a deuce.\n\nAfter the first player has finished, the dealer clears away the cards and places them face down in a pile. The next player then places a bet, and the dealer repeats the same procedure until all the players, including the dealer, have had a turn.\n\nIf at any time, the pot has no more chips in it (because a player has \"bet the pot\" and won), each player again puts in one chip to restore\u00a0the pot.\n\nWhen every player has had a turn to bet, the deal passes to the player on the dealer's left, and the game continues.",
    "input_description": "Example: \n{\"common\": {\"num_players\": 4, \"current_player\": 0, \"dealer\": 3, \"pot\": 27, \"community_cards\": {\"faceup_cards\": []}, \"facedown_cards\": {\"deck_size\": 41}, \"is_over\": false, \"winner\": null}, \"players\": [{\"public\": {\"chips\": 2, \"current_player\": true}}, {\"public\": {\"chips\": 1}}, {\"public\": {\"chips\": 7}}, {\"public\": {\"chips\": 3}}], \"recent_history\": [{\"type\": \"action\", \"player_id\": 0, \"action\": {\"action\": \"bet\", \"args\": {\"bet\": 1}, \"id\": 0}, \"msg\": \"Player 0 decides to: bet-(bet: 1)\"}, {\"type\": \"info\", \"msg\": \"Player 0's action: {'action': 'bet', 'args': {'bet': 1}, 'id': 0}\", \"role\": null}, {\"type\": \"info\", \"msg\": \"Player 0 bets 1 chips.\", \"role\": null}, {\"type\": \"info\", \"msg\": \"Third card drawn is Q-clubs.\", \"role\": null}, {\"type\": \"info\", \"msg\": \"Player 0 loses 1 chips to the pot.\", \"role\": null}, {\"type\": \"turn_end\", \"player_id\": 0, \"msg\": \"---------- End of Player 0's turn ----------\"}, {\"type\": \"action\", \"player_id\": 1, \"action\": {\"action\": \"bet\", \"args\": {\"bet\": 8}, \"id\": 7}, \"msg\": \"Player 1 decides to: bet-(bet: 8)\"}, {\"type\": \"info\", \"msg\": \"Player 1's action: {'action': 'bet', 'args': {'bet': 8}, 'id': 7}\", \"role\": null}, {\"type\": \"info\", \"msg\": \"Player 1 bets 8 chips.\", \"role\": null}, {\"type\": \"info\", \"msg\": \"Third card drawn is 8-clubs.\", \"role\": null}, {\"type\": \"info\", \"msg\": \"Player 1 loses 8 chips to the pot.\", \"role\": null}, {\"type\": \"info\", \"msg\": \"Dealer moves to player 3. Next player is 0.\", \"role\": null}], \"legal_actions\": [{\"action\": \"bet\", \"args\": {\"bet\": 1}, \"id\": 0}, {\"action\": \"bet\", \"args\": {\"bet\": 2}, \"id\": 1}]}\n\nExplanation: \n{\"common\": {\"num_players\": \"The total number of players participating in the game, an integer value.\", \"current_player\": \"The index of the player whose turn it currently is, an integer value.\", \"dealer\": \"The index of the player who is currently the dealer, an integer value.\", \"pot\": \"The total number of chips currently in the pot, an integer value.\", \"community_cards\": {\"faceup_cards\": \"A list of community cards that are currently face-up on the table. At this point, it's an empty list.\"}, \"facedown_cards\": {\"deck_size\": \"The number of cards remaining in the deck, an integer value representing the size of the deck.\"}, \"is_over\": \"A boolean indicating whether the game is over.\", \"winner\": \"The index of the player who has won the game, or null if there is no winner yet.\"}, \"players\": [{\"public\": {\"chips\": \"The number of chips that player 0 currently has, an integer value.\", \"current_player\": \"A boolean indicating if this player is the current player, only present for Player 0.\"}}, {\"public\": {\"chips\": \"The number of chips that player 1 currently has, an integer value.\"}}, {\"public\": {\"chips\": \"The number of chips that player 2 currently has, an integer value.\"}}, {\"public\": {\"chips\": \"The number of chips that player 3 currently has, an integer value.\"}}], \"recent_history\": [{\"type\": \"The type of recent event/action, such as 'action', 'info', or 'turn_end'.\", \"player_id\": \"The index of the player associated with this action or turn end, if applicable.\", \"action\": {\"action\": \"The specific type of action taken by the player (e.g., 'bet').\", \"args\": \"Additional arguments related to the action, such as bet amount.\", \"id\": \"A unique identifier for the action.\"}, \"msg\": \"A human-readable message describing the event.\", \"role\": \"The role or perspective from which the message is generated, often null.\"}, {\"type\": \"The type of recent event/action, such as 'info'.\", \"msg\": \"A human-readable message describing game information or progress.\", \"role\": \"The role or perspective from which the message is generated, often null.\"}], \"legal_actions\": [{\"action\": \"The type of legal action currently available to the current player, such as 'bet'.\", \"args\": {\"bet\": \"The amount that can be bet in this particular legal action.\"}, \"id\": \"A unique identifier for the legal action option.\"}]}",
    "policy_list": [
        "**Betting Range Potential**\nCalculates the likelihood of the third card landing between the two face-up cards. It considers the number of ranks between the two cards and assigns a higher value for more potential outcomes that benefit the player, affecting the betting decision.",
        "**Pot Odds Ratio**\nAssesses the ratio of the current betting opportunity relative to the size of the pot. A higher pot relative to possible winning potential encourages riskier bets, and this metric influences whether to bet conservatively or aggressively.",
        "**Face Card Pair Status**\nChecks if the two face-up cards form a special pair (such as Acey-Deucey or consecutive cards). Pair status drastically changes the risk and reward dynamic and determines special betting strategies like betting the whole pot on Acey-Deucey.",
        "**Current Chip Advantage**\nMeasures the AI's current chip lead or disadvantage compared to other players. This encourages strategic adjustments: more aggressive bets when leading to capitalize on advantage, or conservative plays when trailing to avoid elimination."
    ],
    "code": [
        "\ndef score(state: dict, action: dict) -> float:\n    def rank_value(card_rank: str) -> int:\n        \"\"\"Map card ranks to numerical values to calculate differences.\"\"\"\n        rank_dict = {\n            \"A\": 14, \"K\": 13, \"Q\": 12, \"J\": 11, \"10\": 10, \n            \"9\": 9, \"8\": 8, \"7\": 7, \"6\": 6, \"5\": 5, \n            \"4\": 4, \"3\": 3, \"2\": 2\n        }\n        return rank_dict[card_rank]\n\n    result_score = 0.0\n    \n    # Extract face-up cards\n    faceup_cards = state['common']['community_cards']['faceup_cards']\n    \n    # If there are no face-up cards or less than 2, it is not possible to score\n    if len(faceup_cards) < 2:\n        return result_score\n    \n    # Get rank values for the two face-up cards\n    card1_rank = rank_value(faceup_cards[0][0])\n    card2_rank = rank_value(faceup_cards[1][0])\n    \n    # Calculate ranks difference\n    rank_diff = abs(card1_rank - card2_rank)\n\n    # Calculate the Betting Range Potential\n    # We use rank_diff - 1 because the range between cards excludes the cards themselves\n    if rank_diff > 1:\n        # Calculate the potential rank number between the two cards\n        potential_between = rank_diff - 1\n        max_potential_between = 12  # max difference between 2 and A, without extremes and including all cards rank differences\n        result_score = potential_between / max_potential_between\n    elif card1_rank == card2_rank:\n        # If the same potential win case (like 2 chips),\n        # Assume a near perfect score since the player automatically wins or gains chips\n        result_score = 0.95\n    else:\n        # Rank difference is 1, indicating consecutive cards, auto lose\n        result_score = 0.0\n    \n    return result_score\n\n# Example usage:\nstate_example = {\n    \"common\": {\"num_players\": 4, \"current_player\": 0, \"dealer\": 3, \"pot\": 27, \n               \"community_cards\": {\"faceup_cards\": [\"9\", \"5\"]}, \n               \"facedown_cards\": {\"deck_size\": 41}, \"is_over\": False, \"winner\": None},\n    \"players\": [{\"public\": {\"chips\": 2, \"current_player\": True}}, \n                {\"public\": {\"chips\": 1}}, {\"public\": {\"chips\": 7}}, \n                {\"public\": {\"chips\": 3}}],\n    \"recent_history\": [],\n    \"legal_actions\": [{\"action\": \"bet\", \"args\": {\"bet\": 1}, \"id\": 0},\n                      {\"action\": \"bet\", \"args\": {\"bet\": 2}, \"id\": 1}]\n}\n\naction_example = {\"action\": \"bet\", \"args\": {\"bet\": 1}, \"id\": 0}\nscore_value = score(state_example, action_example)\n#print(score_value)  # This would print the score based on the state\n",
        "\ndef score(state: dict, action: dict) -> float:\n    # Extract key information from the state dictionary\n    common = state['common']\n    current_player_chips = state['players'][common['current_player']]['public']['chips']\n\n    # Determine the action bet value\n    action_bet = action['args']['bet']\n    \n    # Get the number of cards in deck\n    deck_size = common['facedown_cards']['deck_size']\n    \n    # Calculate the pot odds ratio\n    pot_odds = action_bet / (common['pot'] + action_bet)\n\n    # Calculate the range of cards that fall between the two face-up cards\n    card_between_range = 0\n    if common['community_cards']['faceup_cards']:\n        rank_map = {'2': 2, '3': 3, '4': 4, '5': 5, '6': 6, '7': 7, '8': 8, '9': 9, '10': 10, 'J': 11, 'Q': 12, 'K': 13, 'A': 14}\n        if len(common['community_cards']['faceup_cards']) == 2:\n            card1, card2 = sorted([rank_map[common['community_cards']['faceup_cards'][0]], \n                                   rank_map[common['community_cards']['faceup_cards'][1]]])\n            card_between_range = max(0, card2 - card1 - 1)\n    \n    # Estimate the probability of drawing a card between the two face-up cards\n    probability_of_winning = card_between_range / deck_size if deck_size > 0 else 0\n    \n    # Adjust the probability based on pot odds\n    expected_value_factor = 1 - pot_odds\n\n    # The final score calculation biases towards the potential for a winning card draw adjusted by the pot odds.\n    result_score = probability_of_winning * expected_value_factor\n\n    # Ensure the score is between 0 and 1\n    result_score = max(0.0, min(1.0, result_score))\n    \n    return result_score\n",
        "\ndef score(state: dict, action: dict) -> float:\n    # Helper function logic inside score itself\n    def card_rank_value(rank):\n        rank_value_map = {\n            'A': 14, 'K': 13, 'Q': 12, 'J': 11, '10': 10,\n            '9': 9, '8': 8, '7': 7, '6': 6, '5': 5,\n            '4': 4, '3': 3, '2': 2\n        }\n        return rank_value_map.get(rank, 0)\n\n    # Extract necessary game state information\n    faceup_cards = state[\"common\"][\"community_cards\"][\"faceup_cards\"]\n    pot = state[\"common\"][\"pot\"]\n    current_player = state[\"common\"][\"current_player\"]\n    player_chips = state[\"players\"][current_player][\"public\"][\"chips\"]\n    legal_actions = state[\"legal_actions\"]\n    \n    # Extract relevant action information\n    action_id = action.get(\"id\")\n    action_args = action.get(\"args\", {})\n    bet_amount = action_args.get(\"bet\", 1) if action_id is not None else 0\n\n    # Initial reward\n    result_score = 0.0\n\n    # Calculate reward based on face-up cards\n    if len(faceup_cards) == 2:\n        card1, card2 = faceup_cards\n        rank1, rank2 = card1[0], card2[0]\n        value1 = card_rank_value(rank1)\n        value2 = card_rank_value(rank2)\n\n        # Handle special cases\n        if value1 == value2:\n            # Pair case\n            result_score = min(1.0, (pot - player_chips) / pot) if value1 == 14 or value1 == 2 else min(1.0, pot / player_chips) * 0.5\n        elif abs(value1 - value2) == 1:\n            # Consecutive case - automatically lose\n            result_score = 0.0\n        else:\n            # Regular case\n            low_card, high_card = sorted([value1, value2])\n            gap = high_card - low_card - 1\n            deck_size = state[\"common\"][\"facedown_cards\"][\"deck_size\"]\n            \n            # Calculate chance of winning by drawing the 'in-between' card\n            probability = gap / deck_size\n            max_possible_bet = min(pot, player_chips)\n            result_score = probability * (bet_amount / max_possible_bet)\n    \n    # Ensure result is bound between 0 and 1\n    result_score = max(min(result_score, 1.0), 0.0)\n\n    return result_score\n",
        "\ndef score(state: dict, action: dict) -> float:\n    # Extract common game information\n    common = state['common']\n    num_players = common['num_players']\n    current_player = common['current_player']\n    pot = common['pot']\n    \n    # Extract player-specific information\n    player_chips = state['players'][current_player]['public']['chips']\n    \n    # Extract the bet amount from the action\n    bet_amount = action['args']['bet']\n    \n    # Calculate total chips in the game\n    total_chips = sum(player['public']['chips'] for player in state['players']) + pot\n    \n    # Compute the relative chip advantage as a proportion of the total chips\n    relative_chip_position = player_chips / total_chips\n    \n    # Calculate the risk-level based on the bet size relative to player's total chips\n    bet_risk_level = bet_amount / (player_chips if player_chips > 0 else 1)\n    \n    # Develop a score that combines chip advantage with risk adjusted by the potential reward (pot)\n    if pot > 0:\n        potential_reward_ratio = bet_amount / pot\n    else:\n        potential_reward_ratio = 1  # If pot is zero, max reward if pot is restored with ante\n\n    # Weigh the components using importance (these weights can be adjusted based on experimentation)\n    score = 0.5 * relative_chip_position + 0.3 * (1 - bet_risk_level) + 0.2 * potential_reward_ratio\n    \n    # Ensure the result_score is between 0 and 1\n    result_score = min(max(score, 0), 1)\n    \n    return result_score\n\n# Example call\n# state = {\"common\": {...}, \"players\": [...], \"recent_history\": [...], \"legal_actions\": [...]}\n# action = {\"action\": \"bet\", \"args\": {\"bet\": 1}, \"id\": 0}\n# #print(score(state, action))\n"
    ]
}