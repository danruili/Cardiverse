{
    "game_description": "In-Between is not very popular at casinos, but is often played in home Poker games as a break from Poker itself. The rules below are for the home game, which is easily adaptable for casino play.\n\n### Rank of Cards\n\nA (high), K, Q, J, 10, 9, 8, 7, 6, 5, 4, 3, 2.\n\n### Object of the Game\n\nThe goal is to be the player with the most chips at the end of the game.\n\n### The Ante\n\nChips are distributed to the players, and each players puts one chip in the center of the table to form a pool or pot.\n\n### The Draw\n\nAny player deals one card face up, to each player in turn, and the player with the highest card deals first.\n\n### The Shuffle, Cut, and Deal\n\nAny player may shuffle, and the dealer shuffles last. The player to the dealer's right cuts the cards. The dealer turns up two cards and places them in the middle of the table, positioning them so that there is ample room for a third card to fit in between.\n\n### The Betting\n\nThe player on the dealer's left may bet up to the entire pot or any portion of the number of chips in the pot, but they must always bet a minimum of one chip. When the player has placed a bet, the dealer turns up the top card from the pack and places it between the two cards already face up. If the card ranks between the two cards already face up, the player wins and takes back the amount of his bet plus an equivalent amount from the pot. If the third card is not between the face-up cards, or is of the same rank as either of them, the player loses his bet, and it is added to the pot. If the two face-up cards up are consecutive, the player automatically loses, and a third card need not be turned up. If the two face-up cards are the same, the player wins two chips and, again, no third card is turned up. (In some games, the player is paid three chips when this occurs.)\n\n\"Acey-Deucey\" (ace, 2) is the best combination, and a player tends to bet the whole pot, if they can. This is because the only way an ace-deuce combination can lose is if the third card turned up is also an ace or a deuce.\n\nAfter the first player has finished, the dealer clears away the cards and places them face down in a pile. The next player then places a bet, and the dealer repeats the same procedure until all the players, including the dealer, have had a turn.\n\nIf at any time, the pot has no more chips in it (because a player has \"bet the pot\" and won), each player again puts in one chip to restore\u00a0the pot.\n\nWhen every player has had a turn to bet, the deal passes to the player on the dealer's left, and the game continues.",
    "input_description": "Example: \n{\"common\": {\"num_players\": 4, \"current_player\": 0, \"dealer\": 3, \"pot\": 7, \"community_cards\": {\"faceup_cards\": []}, \"facedown_cards\": {\"deck_size\": 38}, \"is_over\": false, \"winner\": null}, \"players\": [{\"public\": {\"chips\": 9, \"current_player\": true}}, {\"public\": {\"chips\": 7}}, {\"public\": {\"chips\": 10}}, {\"public\": {\"chips\": 7}}], \"recent_history\": [{\"type\": \"action\", \"player_id\": 0, \"action\": {\"action\": \"bet\", \"args\": {\"bet\": 3}, \"id\": 2}, \"msg\": \"Player 0 decides to: bet-(bet: 3)\"}, {\"type\": \"info\", \"msg\": \"Player 0's action: {'action': 'bet', 'args': {'bet': 3}, 'id': 2}\", \"role\": null}, {\"type\": \"info\", \"msg\": \"Player 0 bets 3 chips.\", \"role\": null}, {\"type\": \"info\", \"msg\": \"Third card drawn is A-diamonds.\", \"role\": null}, {\"type\": \"info\", \"msg\": \"Player 0 loses 3 chips to the pot.\", \"role\": null}, {\"type\": \"turn_end\", \"player_id\": 0, \"msg\": \"---------- End of Player 0's turn ----------\"}, {\"type\": \"action\", \"player_id\": 1, \"action\": {\"action\": \"bet\", \"args\": {\"bet\": 1}, \"id\": 0}, \"msg\": \"Player 1 decides to: bet-(bet: 1)\"}, {\"type\": \"info\", \"msg\": \"Player 1's action: {'action': 'bet', 'args': {'bet': 1}, 'id': 0}\", \"role\": null}, {\"type\": \"info\", \"msg\": \"Player 1 bets 1 chips.\", \"role\": null}, {\"type\": \"info\", \"msg\": \"Third card drawn is Q-diamonds.\", \"role\": null}, {\"type\": \"info\", \"msg\": \"Player 1 loses 1 chips to the pot.\", \"role\": null}, {\"type\": \"info\", \"msg\": \"Dealer moves to player 3. Next player is 0.\", \"role\": null}], \"legal_actions\": [{\"action\": \"bet\", \"args\": {\"bet\": 1}, \"id\": 0}, {\"action\": \"bet\", \"args\": {\"bet\": 2}, \"id\": 1}, {\"action\": \"bet\", \"args\": {\"bet\": 3}, \"id\": 2}, {\"action\": \"bet\", \"args\": {\"bet\": 4}, \"id\": 3}, {\"action\": \"bet\", \"args\": {\"bet\": 5}, \"id\": 4}, {\"action\": \"bet\", \"args\": {\"bet\": 6}, \"id\": 5}, {\"action\": \"bet\", \"args\": {\"bet\": 7}, \"id\": 6}]}\n\nExplanation: \n{\"common\": \"A dictionary that holds the shared state of the game, relevant to all players.\", \"common.num_players\": \"The total number of players in the game, as an integer.\", \"common.current_player\": \"The index of the player who is currently taking their turn, as an integer.\", \"common.dealer\": \"The index of the player who is acting as the dealer, as an integer.\", \"common.pot\": \"The total number of chips currently in the pot, as an integer.\", \"common.community_cards\": \"A dictionary listing the community cards visible to all players.\", \"common.community_cards.faceup_cards\": \"A list representing the community cards that are currently face up.\", \"common.facedown_cards\": \"A dictionary that represents cards that are not visible or face down.\", \"common.facedown_cards.deck_size\": \"An integer denoting the number of cards left in the deck.\", \"common.is_over\": \"A boolean value indicating whether the game has ended. 'True' for ended, 'False' for ongoing.\", \"common.winner\": \"The index of the winner at the end of the game, or null if the game is still in progress.\", \"players\": \"A list containing a dictionary for each player, representing their individual game state.\", \"players[n].public\": \"A dictionary containing public information about the nth player.\", \"players[0].public.chips\": \"An integer representing the number of chips currently held by player 0.\", \"players[0].public.current_player\": \"A boolean indicating if this player is the current player. 'True' if yes, omitted or 'False' otherwise.\", \"recent_history\": \"A list of dictionaries representing the recent actions and events in the game.\", \"recent_history[].type\": \"A string that represents the type of event. Possible values include 'action', 'info', and 'turn_end'.\", \"recent_history[].player_id\": \"The index of the player involved in the action or event, when applicable.\", \"recent_history[].action\": \"A dictionary detailing actions taken by a player, including the action type and any arguments passed with it.\", \"recent_history[].msg\": \"A string providing a descriptive message of the event or action that took place.\", \"legal_actions\": \"A list of dictionaries representing the possible actions the current player can take.\", \"legal_actions[].action\": \"A string indicating the type of action available. The example shows 'bet'.\", \"legal_actions[].args\": \"A dictionary containing any necessary arguments related to the action, such as the bet amount.\", \"legal_actions[].id\": \"An identifier for the action, often used internally to track or apply the action later.\"}",
    "policy_list": [
        "**Refined Wide Range Betting Strategy**\nThe 'Wide Range' condition should be clarified as having at least four card ranks between the two face-up cards (e.g., a 2 and a 6, or a Jack and an Ace). A high bet should be placed when 'Betting Range Potential' is high, meaning there are many ranks between the two face-up cards. Additionally, before placing a high bet, assess the 'Pot Odds Ratio' to ensure that the potential reward justifies the risk. If the ratio is favorable and the AI has a 'Current Chip Advantage,' an aggressive bet close to the pot size is recommended. A 'Face Card Pair Status' of Acey-Deucey overrides other factors, prompting a bet of the whole pot due to the low risk of loss.",
        "**Minimum Bet on Consecutive Cards**\nWhen the two face-up cards are consecutive (e.g., a 7 and an 8), the player should bet the minimum amount required. This approach conditions on realizing the 'Face Card Pair Status,' acknowledging that consecutive cards guarantee a loss because no possible card can fall between them. Therefore, betting the minimum effectively curtails potential losses arising from this situation.",
        "**Bet Pot on Acey-Deucey with Strategic Considerations**\nRefined Strategy: Always bet the entire pot when the face-up cards are an Ace and a Deuce, due to the exceptionally low likelihood of losing this bet. In addition, evaluate the Betting Range Potential of non-Acey-Deucey hands to assess the likelihood of the third card falling within the range. Calculate the Pot Odds Ratio to decide if the bet aligns with the potential reward\u2014considering larger bets when the pot is significantly large in comparison to the bet size. Factor in the Current Chip Advantage; with a higher chip advantage, consider riskier bets, whereas a low advantage warrants more conservative plays. These metrics will help optimize decisions beyond just the Acey-Deucey scenario.",
        "**Refined Moderate Betting on Equal Cards**\nThe strategy suggests placing a bet not exceeding half the pot when the face-up cards are of equal rank. This move capitalizes on the certain win (gaining two or three chips) without risking excessive loss. To refine the strategy, the bet size should dynamically adjust based on two game state metrics: (1) 'Current Chip Advantage': If the AI is leading, it may safely bet up to half the pot; if trailing, it might be more conservative, reducing the bet to a quarter of the pot to minimize risk while ensuring some gain. (2) 'Pot Odds Ratio': If the pot is large compared to typical rounds, it slightly increases the bet within the 'half the pot' range, capturing potential gains without heavy risk. These adjustments ensure the strategy remains effective across various game conditions."
    ],
    "code": [
        "\ndef score(state: dict, action: dict) -> float:\n    # Extract the necessary state details\n    common = state['common']\n    players = state['players']\n    current_player_id = common['current_player']\n    pot_size = common['pot']\n    faceup_cards = common['community_cards']['faceup_cards']\n    current_player = players[current_player_id]['public']\n    bet_amount = action['args']['bet']\n\n    # Check if face-up cards are available and evaluate betting conditions\n    if len(faceup_cards) == 2:\n        card1_rank = faceup_cards[0]['rank']\n        card2_rank = faceup_cards[1]['rank']\n\n        # Convert rank to numeric for comparison\n        rank_values = {'2': 2, '3': 3, '4': 4, '5': 5, '6': 6, '7': 7, '8': 8, '9': 9,\n                       '10': 10, 'J': 11, 'Q': 12, 'K': 13, 'A': 14}\n\n        # Numeric value of the ranks\n        card1_value = rank_values[card1_rank]\n        card2_value = rank_values[card2_rank]\n\n        # Calculate range between cards\n        card_range = abs(card1_value - card2_value) - 1\n\n        # Determine betting range potential\n        if card_range >= 4:\n            betting_potential = 1  # Wide betting range\n        else:\n            betting_potential = card_range / 4  # Scaled from 0 to 1\n\n        # Evaluate Pot Odds Ratio\n        pot_odds_ratio = bet_amount / pot_size\n        if pot_odds_ratio < 0.5:\n            odds_factor = 1  # Favorable odds\n        else:\n            odds_factor = (1 - pot_odds_ratio)\n\n        # Calculate chip advantage\n        total_chips = sum([player['public']['chips'] for player in players])\n        chip_advantage = current_player['chips'] / total_chips\n\n        # Special condition for Acey-Deucey\n        if (card1_value == 14 and card2_value == 2) or (card1_value == 2 and card2_value == 14):\n            return 1.0  # Best hand, always bet full\n\n        # Combine metrics into a final score\n        result_score = betting_potential * odds_factor * chip_advantage\n\n        # Normalize to ensure within 0 to 1\n        result_score = min(max(result_score, 0), 1)\n    else:\n        # Default to lower chance if no cards are face up (less information)\n        result_score = 0.2\n\n    return result_score\n",
        "\ndef score(state: dict, action: dict) -> float:\n    def get_card_rank(card: str) -> int:\n        rank = card.split('-')[0]\n        rank_values = {'A': 14, 'K': 13, 'Q': 12, 'J': 11,\n                       '10': 10, '9': 9, '8': 8, '7': 7,\n                       '6': 6, '5': 5, '4': 4, '3': 3, '2': 2}\n        return rank_values.get(rank, 0)\n\n    def is_consecutive(cards: list) -> bool:\n        if len(cards) != 2:\n            return False\n        ranks = sorted([get_card_rank(card) for card in cards])\n        return ranks[1] - ranks[0] == 1\n\n    faceup_cards = state['common']['community_cards']['faceup_cards']\n    pot_size = state['common']['pot']\n    bet_amount = action['args']['bet']\n    \n    if not faceup_cards or len(faceup_cards) < 2:\n        return 0.0\n\n    low_card, high_card = sorted(get_card_rank(card) for card in faceup_cards)\n    \n    if is_consecutive(faceup_cards):\n        return 0.0\n\n    if low_card == high_card:\n        return 1.0\n    \n    total_possible_cards = 13\n    possible_winning_cards = high_card - low_card - 1\n    win_probability = possible_winning_cards / total_possible_cards\n    \n    potential_gain = min(bet_amount, pot_size)\n    if pot_size > 0:\n        action_value = win_probability * potential_gain / pot_size\n    else:\n        action_value = win_probability\n    \n    result_score = max(0.0, min(1.0, action_value))\n    \n    return result_score\n",
        "\ndef score(state: dict, action: str) -> float:\n    \"\"\"\n    Estimates the probability of winning the game based on the current game state and the proposed action.\n\n    :param state: A dictionary representing the current game state.\n    :param action: A string representing the action being considered (e.g., \"bet\").\n    :return: A float between 0 and 1 representing the estimated probability of winning.\n    \"\"\"\n    import math\n\n    # Helper function to get a numerical value for a card rank\n    def get_card_value(card: str) -> int:\n        card_rank_order = {'2': 2, '3': 3, '4': 4, '5': 5, '6': 6, '7': 7, \n                           '8': 8, '9': 9, '10': 10, 'J': 11, 'Q': 12, 'K': 13, 'A': 14}\n        return card_rank_order.get(card, 0)\n\n    common = state['common']\n    pot_size = common['pot']\n    deck_size = common['facedown_cards']['deck_size']\n    faceup_cards = common['community_cards']['faceup_cards']\n\n    current_player_idx = common['current_player']\n    current_player_chips = state['players'][current_player_idx]['public']['chips']\n\n    # Define some base reward\n    result_score = 0.0\n\n    # Check if the hand is \"Acey-Deucey\"\n    if faceup_cards == ['A', '2'] or faceup_cards == ['2', 'A']:\n        # High reward for Acey-Deucey\n        result_score = 0.95\n\n    elif len(faceup_cards) < 2:\n        # Invalid state, should not happen in a legitimate game state\n        return 0.0\n\n    else:\n        card1, card2 = faceup_cards\n        card1_value = get_card_value(card1)\n        card2_value = get_card_value(card2)\n\n        if card1_value == card2_value + 1 or card2_value == card1_value + 1:\n            # Consecutive cards, auto-loss\n            result_score = 0.0\n        elif card1_value == card2_value:\n            # Pair, auto-win situation as per the rules\n            result_score = 0.7\n        else:\n            # Calculate the range between the two faceup cards\n            low_card, high_card = sorted((card1_value, card2_value))\n            potential_win_cards = high_card - low_card - 1\n            result_score = potential_win_cards / deck_size\n\n    # Pot Odds Ratio consideration\n    bet_action = next((act for act in state['legal_actions'] if act['id'] == action), None)\n    if bet_action:\n        bet_amount = bet_action['args']['bet']\n        pot_odds_ratio = bet_amount / pot_size\n        result_score *= (1 + pot_odds_ratio)\n\n    # Adjust score based on chip advantage\n    average_chips = sum(player['public']['chips'] for player in state['players']) / len(state['players'])\n    chip_advantage_factor = (current_player_chips / average_chips) if average_chips != 0 else 1\n    result_score *= chip_advantage_factor\n\n    # Normalize the result_score to be between 0 and 1\n    result_score = max(0.0, min(result_score, 1.0))\n\n    return result_score\n",
        "\ndef score(state: dict, action: dict) -> float:\n    common = state[\"common\"]\n    current_player = common[\"current_player\"]\n    pot = common[\"pot\"]\n    community_cards = common[\"community_cards\"][\"faceup_cards\"]\n\n    players = state[\"players\"]\n    player_chips = players[current_player][\"public\"][\"chips\"]\n    num_players = common[\"num_players\"]\n\n    # Calculate player's chip advantage\n    total_chips = sum(player[\"public\"][\"chips\"] for player in players)\n    chip_advantage = player_chips / total_chips\n\n    # Check current bet\n    bet = action[\"args\"][\"bet\"]\n\n    # Calculate Pot Odds Ratio\n    max_pot_size = total_chips\n    pot_odds_ratio = pot / max_pot_size\n\n    # Determine potential probability boost from equal rank cards\n    equal_cards_potential = 0\n    if len(community_cards) == 2 and community_cards[0] == community_cards[1]:\n        # Let's set a baseline potential probability boost for having equal cards\n        equal_cards_potential = 0.1\n\n    # Calculate a preliminary win probability\n    base_probability = chip_advantage * 0.5 + pot_odds_ratio * 0.3 + equal_cards_potential\n\n    # Factor in current bet size\n    proportion_of_pot_bet = bet / pot if pot else 0\n    if equal_cards_potential > 0:\n        # Safely bet up to half the pot when cards are equal, otherwise calculate risk based on bet size\n        bet_factor = 0.5 if (bet <= pot / 2) else 0\n    else:\n        bet_factor = 0.4 * (1 - proportion_of_pot_bet)\n\n    # Finalize the result score\n    result_score = min(1.0, base_probability + bet_factor)\n\n    return result_score\n"
    ]
}