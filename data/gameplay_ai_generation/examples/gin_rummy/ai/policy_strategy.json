{
    "game_description": "This document outlines the rules for the card game Gin Rummy, as implemented in the provided code.\n\n### 1. Game Objective\n\nThe primary goal in Gin Rummy is to form a hand where most or all of your cards are part of valid combinations called **melds**. By doing so, you aim to reduce the value of your unmatched cards, known as **deadwood**, to a minimum. A player can win a round by \"going Gin\" (having a hand with zero deadwood) or by \"knocking\" with a low deadwood count.\n\n### 2. Game Setup\n\n* **Players:** The game is designed for two players.\n* **Deck:** A standard 52-card deck is used.\n* **Dealing:**\n    * One player is designated as the dealer.\n    * The non-dealer is dealt 11 cards, and the dealer receives 10 cards.\n    * The remaining cards form the **stock pile**, which is placed face down. The top card of the stock pile is turned face up to start the **discard pile**.\n\n### 3. Gameplay\n\nThe game proceeds in turns, starting with the non-dealer. A player's turn consists of two main actions: a **draw** and a **discard**.\n\n#### 3.1. The Draw\n\nAt the beginning of your turn, you must take one card from either:\n\n* The **stock pile** (the face-down deck).\n* The **discard pile** (the face-up pile of discarded cards). You may only take the top card of the discard pile.\n\n#### 3.2. The Discard\n\nAfter drawing a card, you will have 11 cards in your hand. You must then choose one card to discard, placing it face up on top of the discard pile.\n\n### 4. Melds\n\nA **meld** is a combination of cards in your hand that helps to reduce your deadwood score. There are two types of melds:\n\n* **Set:** Three or four cards of the same rank (e.g., 7 of Hearts, 7 of Clubs, 7 of Spades).\n* **Run:** Three or more cards of the same suit in sequential order (e.g., 4 of Diamonds, 5 of Diamonds, 6 of Diamonds). Aces are always low in a run (e.g., Ace-2-3 is a valid run, but Queen-King-Ace is not).\n\nA single card cannot belong to more than one meld at the same time.\n\n### 5. Card Values (Deadwood)\n\nThe point values of the cards are as follows:\n\n* **Ace:** 1 point\n* **Number Cards (2-9):** Face value (e.g., a 5 is worth 5 points)\n* **Face Cards (10, Jack, Queen, King):** 10 points each\n\nThe **deadwood count** is the total point value of all the cards in your hand that are not part of a valid meld.\n\n### 6. Ending a Round\n\nThere are three ways a round can end:\n\n#### 6.1. Going Gin\n\nIf, after drawing a card, you can form melds with all 10 of your cards (leaving you with a deadwood count of zero), you can \"go Gin.\" You would discard your 11th card and declare \"Gin.\"\n\n* **Scoring for Gin:** You receive a bonus of 25 points, plus the total deadwood count of your opponent's hand.\n\n#### 6.2. Knocking\n\nIf your deadwood count is 10 or less after drawing a card, you may choose to \"knock.\" To do this, you discard your 11th card and lay down your hand, separating your melds from your deadwood.\n\n* **Lay-offs:** The opponent then has the opportunity to \"lay off\" any of their own deadwood cards that can be added to your melds. For example, if you have a meld of three Kings, and your opponent has the fourth King, they can lay it off. If you have a run of 5-6-7 of Hearts, they can lay off the 4 of Hearts or the 8 of Hearts.\n* **Scoring for Knocking:**\n    * **If your deadwood count is lower than your opponent's (after they have laid off their cards):** You score the difference between your deadwood and their remaining deadwood.\n    * **Undercutting:** If your opponent, after laying off cards, has a deadwood count that is less than or equal to yours, they have \"undercut\" you. In this case, the opponent scores a 25-point bonus, plus the difference in your deadwood counts.\n\n#### 6.3. Dead Hand\n\nIf the stock pile is reduced to only two cards and no player has knocked or gone Gin, the round is declared a \"dead hand,\" and no points are awarded to either player.\n\n",
    "input_description": "Example: \n{\"common\": {\"num_players\": 2, \"current_player\": 1, \"dealer_id\": 1, \"phase\": \"discard\", \"end_type\": null, \"going_out_player\": null, \"knock_card\": null, \"winner\": null, \"is_over\": false, \"facedown_cards\": {\"deck_size\": 30}, \"faceup_cards\": {\"discard_pile\": [{\"rank\": \"T\", \"suit\": \"Clubs\"}], \"final_melds\": {\"player_0\": [], \"player_1\": []}}}, \"players\": [{\"public\": {\"score\": 0}, \"facedown_cards\": {\"hand_size\": 10}, \"faceup_cards\": {\"melds\": []}}, {\"public\": {\"score\": 0, \"current_player\": true}, \"private\": {}, \"facedown_cards\": {\"hand\": [{\"rank\": \"2\", \"suit\": \"Spades\"}, {\"rank\": \"8\", \"suit\": \"Clubs\"}, {\"rank\": \"K\", \"suit\": \"Clubs\"}, {\"rank\": \"4\", \"suit\": \"Clubs\"}, {\"rank\": \"A\", \"suit\": \"Clubs\"}, {\"rank\": \"5\", \"suit\": \"Hearts\"}, {\"rank\": \"9\", \"suit\": \"Spades\"}, {\"rank\": \"Q\", \"suit\": \"Clubs\"}, {\"rank\": \"A\", \"suit\": \"Hearts\"}, {\"rank\": \"9\", \"suit\": \"Diamonds\"}, {\"rank\": \"8\", \"suit\": \"Spades\"}]}, \"faceup_cards\": {\"melds\": []}}], \"recent_history\": [{\"type\": \"action\", \"player_id\": 1, \"action\": {\"action\": \"pickup\", \"id\": 1}, \"msg\": \"Player 1 decides to: pickup\"}, {\"type\": \"info\", \"msg\": \"Player 1 picks up 8-Spades from the discard pile.\", \"role\": null}], \"legal_actions\": [{\"action\": \"discard\", \"args\": {\"card\": \"2-Spades\", \"deadwood\": 65}, \"id\": 0}, {\"action\": \"discard\", \"args\": {\"card\": \"8-Clubs\", \"deadwood\": 59}, \"id\": 1}, {\"action\": \"discard\", \"args\": {\"card\": \"K-Clubs\", \"deadwood\": 57}, \"id\": 2}, {\"action\": \"discard\", \"args\": {\"card\": \"4-Clubs\", \"deadwood\": 63}, \"id\": 3}, {\"action\": \"discard\", \"args\": {\"card\": \"A-Clubs\", \"deadwood\": 66}, \"id\": 4}, {\"action\": \"discard\", \"args\": {\"card\": \"5-Hearts\", \"deadwood\": 62}, \"id\": 5}, {\"action\": \"discard\", \"args\": {\"card\": \"9-Spades\", \"deadwood\": 58}, \"id\": 6}, {\"action\": \"discard\", \"args\": {\"card\": \"Q-Clubs\", \"deadwood\": 57}, \"id\": 7}, {\"action\": \"discard\", \"args\": {\"card\": \"A-Hearts\", \"deadwood\": 66}, \"id\": 8}, {\"action\": \"discard\", \"args\": {\"card\": \"9-Diamonds\", \"deadwood\": 58}, \"id\": 9}, {\"action\": \"discard\", \"args\": {\"card\": \"8-Spades\", \"deadwood\": 59}, \"id\": 10}]}\n\nExplanation: \n{\"common\": \"A dictionary containing non-player-specific information about the current game state.\", \"common.num_players\": \"The total number of players in the game, which is 2 for Gin Rummy.\", \"common.current_player\": \"The player ID of the current player whose turn it is to act (0 or 1).\", \"common.dealer_id\": \"The ID of the player who is the dealer for this round; the dealer changes each round.\", \"common.phase\": \"The current phase of the game, which can be 'deal', 'discard', 'draw', or 'game_over'.\", \"common.end_type\": \"Indicates how the round ended: 'knock', 'gin', 'dead_hand', or null if the game is still ongoing.\", \"common.going_out_player\": \"The player ID of the player who is going out by knocking or ginning. Null if no player is going out.\", \"common.knock_card\": \"The card used by a player to indicate they are knocking. Null if there is no knock.\", \"common.winner\": \"The player ID of the winner of the round. Null if the round has not been won.\", \"common.is_over\": \"Boolean indicating whether the game is over or not.\", \"common.facedown_cards\": \"A dictionary containing information about facedown cards, like the deck.\", \"common.facedown_cards.deck_size\": \"The number of cards remaining in the deck.\", \"common.faceup_cards\": \"A dictionary containing information about faceup cards.\", \"common.faceup_cards.discard_pile\": \"A list of card objects representing the discard pile. Each card has a 'rank' and a 'suit'.\", \"common.faceup_cards.final_melds\": \"A dictionary recording the final melds for each player ('player_0', 'player_1'), which are filled at the end of the game.\", \"players\": \"A list containing information specific to each player in the game. Each player is represented by a dictionary.\", \"players[n].public\": \"A dictionary containing public information about player n, including their score.\", \"players[n].facedown_cards\": \"A dictionary containing the player's facedown cards, like their hand.\", \"players[n].facedown_cards.hand_size\": \"Specifies the number of cards in the player's hand. Used primarily when only hand size is public.\", \"players[n].faceup_cards\": \"A dictionary containing the player's faceup cards, such as melds revealed at the end of a hand.\", \"players[n].faceup_cards.melds\": \"A list of melds (groups of cards) the player has created from their hand. Empty during the game as melds are shown at the end.\", \"recent_history\": \"A list of the most recent actions taken in the game, stored as dictionaries.\", \"recent_history[].type\": \"The type of entry, such as 'action' or 'info', indicating whether it's player action or game information.\", \"recent_history[].player_id\": \"The ID of the player who performed the action, relevant for 'action' type entries.\", \"recent_history[].action\": \"A dictionary of action details, relevant for 'action' type entries.\", \"recent_history[].msg\": \"A message describing the recent action or event.\", \"legal_actions\": \"A list of dictionaries representing the legal actions the current player can take, each with an 'action' and optionally 'args'.\", \"legal_actions[].action\": \"The type of action a player can take, such as 'discard'.\", \"legal_actions[].args\": \"A dictionary of arguments for the action, such as 'card' to specify a card to discard and 'deadwood' indicating deadwood value after action.\"}",
    "policy_list": [
        "**Prioritize Building Melds**\nFocus on forming sets and runs early in the game to minimize deadwood quickly. Evaluate your hand to recognize potential combinations and avoid discarding cards that could complete a meld.",
        "**Smart Discarding**\nDiscard cards that are unlikely to form melds and are less likely to be useful to your opponent. Pay attention to the cards your opponent is picking up from the discard pile to infer their strategy and avoid assisting them.",
        "**Calculative Drawing**\nDecide whether to draw from the discard pile based on your current hand composition and the potential to use the top discard card in a meld. Draw from the stock pile if the discard pile does not offer immediate benefits.",
        "**Timely Knocking**\nOpt to knock when your deadwood count is low enough, preferably immediately when it reaches 10 or less, to limit the opponent's lay-off opportunities and maximize the scoring differential."
    ],
    "code": [
        "\ndef score(state: dict, action: dict) -> float:\n    def card_value(card: dict) -> int:\n        \"\"\"Return the deadwood value of a card.\"\"\"\n        rank = card['rank']\n        if rank == 'A':\n            return 1\n        elif rank in 'TJQK':\n            return 10\n        else:\n            return int(rank)\n\n    def potential_melds(hand: list) -> int:\n        \"\"\"Calculate how many potential melds can be completed with this hand.\"\"\"\n        # Group cards by rank and suit\n        ranks = {}\n        suits = {}\n        for card in hand:\n            ranks.setdefault(card['rank'], []).append(card)\n            suits.setdefault(card['suit'], []).append(card)\n\n        # Count potential sets (three or more of the same rank)\n        sets = sum(len(cards) >= 3 for cards in ranks.values())\n\n        # Count potential runs (three or more sequential cards in the same suit)\n        runs = 0\n        for cards in suits.values():\n            if len(cards) >= 3:\n                sorted_cards = sorted(cards, key=lambda x: 'A23456789TJQK'.index(x['rank']))\n                for i in range(len(sorted_cards) - 2):\n                    if (card_value(sorted_cards[i + 1]) == card_value(sorted_cards[i]) + 1 and\n                            card_value(sorted_cards[i + 2]) == card_value(sorted_cards[i + 1]) + 1):\n                        runs += 1\n\n        return sets + runs\n\n    # Extract useful game information\n    current_player_id = state['common']['current_player']\n    current_hand = state['players'][current_player_id]['facedown_cards']['hand']\n    discard_card = action['args']['card']\n\n    # Simulate discard action on player's hand\n    hand_without_discard = [card for card in current_hand if f\"{card['rank']}-{card['suit']}\" != discard_card]\n    \n    # Calculate potential melds before and after the action\n    current_potential_melds = potential_melds(current_hand)\n    potential_melds_after_action = potential_melds(hand_without_discard)\n\n    # Calculate deadwood value after action\n    deadwood_after_action = sum(card_value(card) for card in hand_without_discard)\n\n    # Construct a reward\n    result_score = 0.5\n    # Increase reward if meld potential improves\n    if potential_melds_after_action > current_potential_melds:\n        result_score += 0.3 * (potential_melds_after_action - current_potential_melds)\n    # Decrease reward based on deadwood count\n    result_score -= 0.1 * min(deadwood_after_action / 100, 1)\n\n    # Ensure the reward is between 0 and 1\n    result_score = max(0, min(1, result_score))\n\n    return result_score\n",
        "\ndef score(state: dict, action: dict) -> float:\n    # Import required modules\n    import numpy as np\n\n    # Extract information from the game state and action\n    current_player_id = state['common']['current_player']\n    current_player_hand = state['players'][current_player_id]['facedown_cards']['hand']\n    discard_card = next(card for card in current_player_hand if f\"{card['rank']}-{card['suit']}\" == action['args']['card'])\n    action_deadwood = action['args']['deadwood']\n    \n    # Calculate basic utility from deadwood\n    deadwood_penalty = action_deadwood / 100  # Scale between 0 and 1, lower is better\n    \n    # Evaluate hand for potential melds\n    card_candidates = [card for card in current_player_hand if card != discard_card]\n    ranks = {}\n    suits = {}\n\n    for card in card_candidates:\n        rank = card['rank']\n        suit = card['suit']\n        \n        # Count cards per suit and rank\n        if suit not in suits:\n            suits[suit] = []\n        suits[suit].append(rank)\n        \n        if rank not in ranks:\n            ranks[rank] = 0\n        ranks[rank] += 1\n\n    potential_melds = 0\n    # Check for potential runs\n    for suit in suits:\n        numbers = sorted([{'J': 11, 'Q': 12, 'K': 13, 'A': 1}.get(rank, int(rank)) for rank in suits[suit]])\n        for i in range(len(numbers) - 2):\n            if numbers[i] + 1 == numbers[i + 1] and numbers[i + 1] + 1 == numbers[i + 2]:\n                potential_melds += 1\n    \n    # Check for potential sets\n    potential_melds += sum(1 for count in ranks.values() if count >= 3)\n    \n    # Calculate meld bonus\n    meld_bonus = min(potential_melds * 0.1, 0.5)  # Bonus scaled and limited to 0.5\n\n    # Opponent's needs from discard pile observation\n    opponent_hand_guess = state['recent_history'][-2:]  # Naive assumption\n    assist_penalty = 0\n    for record in opponent_hand_guess:\n        if record['type'] == 'info' and record['msg'].endswith(f\"{discard_card['rank']}-{discard_card['suit']} from the discard pile.\"):\n            assist_penalty += 0.2  # Penalize if the discard likely assists the opponent\n\n    # Combine all factors into a final score\n    result_score = max(0, 1 - deadwood_penalty + meld_bonus - assist_penalty)\n    result_score = min(result_score, 1)  # Stay within 0-1 range\n\n    return result_score\n",
        "\ndef score(state: dict, action: str) -> float:\n    def calculate_deadwood(hand):\n        card_values = {'A': 1, '2': 2, '3': 3, '4': 4, '5': 5, \n                       '6': 6, '7': 7, '8': 8, '9': 9, \n                       'T': 10, 'J': 10, 'Q': 10, 'K': 10}\n        return sum(card_values[card['rank']] for card in hand)\n\n    def can_form_melds(hand):\n        # Dummy function to estimate potential meld formation\n        # A full meld detection function would greatly increase complexity\n        ranks = [card['rank'] for card in hand]\n        suits = [card['suit'] for card in hand]\n        for card in hand:\n            rank_count = ranks.count(card['rank'])\n            if rank_count >= 3:  # Potential set\n                return True\n            suit_count = suits.count(card['suit'])\n            if suit_count >= 3:  # Potential run\n                return True\n        return False\n\n    # Extract the player's hand and evaluate potential\n    player = state['common']['current_player']\n    hand = state['players'][player]['facedown_cards']['hand']\n    deadwood = calculate_deadwood(hand)\n    \n    # Estimate the current potential to form melds\n    mean_deck_size = state['common']['facedown_cards']['deck_size']\n    potential_to_win = (1 - (deadwood / (mean_deck_size * 10)))\n\n    # Check if the action assists the potential to form melds\n    if action['action'] == 'discard':\n        card_to_discard = action['args']['card']\n        new_hand = [card for card in hand if f\"{card['rank']}-{card['suit']}\" != card_to_discard]\n        new_deadwood = calculate_deadwood(new_hand)\n        potential_gain = deadwood - new_deadwood\n        \n        if can_form_melds(new_hand):\n            # Higher reward for forming melds\n            result_score = min(1.0, potential_to_win + 0.2)\n        else:\n            # Reward based on reducing deadwood\n            result_score = min(1.0, potential_to_win + potential_gain / 100)\n\n    else:\n        # Default case if we can't assess improvement, use raw potential\n        result_score = potential_to_win\n\n    return result_score\n",
        "\ndef score(state: dict, action: dict) -> float:\n    def calculate_deadwood(hand):\n        \"\"\"Calculate the total deadwood points for a given hand.\"\"\"\n        values = {'A': 1, '2': 2, '3': 3, '4': 4, '5': 5, '6': 6, '7': 7, \n                  '8': 8, '9': 9, 'T': 10, 'J': 10, 'Q': 10, 'K': 10}\n        return sum(values[card['rank']] for card in hand)\n\n    # Extract relevant information from the game state\n    current_player_id = state['common']['current_player']\n    current_player_hand = state['players'][current_player_id]['facedown_cards']['hand']\n    \n    # Calculate deadwood before action\n    original_deadwood = calculate_deadwood(current_player_hand)\n    \n    # Find the corresponding action to predict score after the action is taken\n    action_type = action['action']\n    action_args = action.get('args', {})\n    \n    if action_type == 'discard':\n        # Simulate the discard action to calculate potential deadwood score\n        card_to_discard = action_args['card']\n        potential_new_hand = [card for card in current_player_hand if (\n            card['rank'] + '-' + card['suit'] != card_to_discard)]\n        \n        # Calculate potential new deadwood\n        new_deadwood = calculate_deadwood(potential_new_hand)\n\n        # The basic policy is that if deadwood is low enough, consider knocking\n        if new_deadwood <= 10:  # threshold to potentially knock\n            # Calculate reward based on the deadwood\n            result_score = 1 - new_deadwood / 10  # scale reward from 0 to 1\n        else:\n            # Decrease reward as deadwood increases\n            result_score = max(0, 0.75 - new_deadwood / 50)  # loose scale based on higher deadwood\n    else:\n        result_score = 0.5  # neutral value when action cannot be evaluated\n\n    return result_score\n"
    ]
}